!rem // _libMidgard()
!rem // 
!rem //   Initializer and publisher function. Call once from autorun.
!rem //
!mmm function _libMidgard()
!mmm   
!mmm   set libVersion = "libMidgard v1.4.0-pre (2022-04-25)"
!mmm   set sender = "MacroSheetLibrary"
!mmm
!rem   // MMM compatibility check: die if MMM version too low
!mmm   if version < 1.28
!mmm     do whisperback("Abbruch: MMM-Version 1.28.0 oder höher erforderlich.")
!mmm     exit script
!mmm   end if
!mmm
!rem   // Game-global constants for publication
!rem
!mmm   set m3mgdScriptCommands = { "defense": "&#x25;{MacroSheet|defense}", "melee": "&#x25;{MacroSheet|meleeAttack}", "ranged": "&#x25;{MacroSheet|rangedAttack}" }
!mmm   set m3mgdExchangeDataSheet = "MacroSheet"
!mmm   set m3mgdExchange = m3mgdExchangeDataSheet.character_id
!mmm 
!mmm   if m3mgdExchange.permission ne "view" and m3mgdExchange.permission ne "control" 
!mmm     do whisperback(libVersion & " - No permission to access Midgard data exchange sheet '" & m3mgdExchangeDataSheet & "'. Data exchange will not work.")
!mmm     do delay(5)
!mmm     return false
!mmm   end if
!mmm
!mmm   set m3mgdAttrAttackType          = "m3mgd_attack_type"
!mmm   set m3mgdAttrAttackerID          = "m3mgd_attack_attackerID"
!mmm   set m3mgdAttrAttackTargetID      = "m3mgd_attack_targetID"
!mmm   set m3mgdAttrAttackResult        = "m3mgd_attack_result"
!mmm   set m3mgdAttrAttackDamage        = "m3mgd_attack_damage"
!mmm   set m3mgdAttrAttackDamageRoll    = "m3mgd_attack_damage_roll"
!mmm   set m3mgdAttrAttackWeaponType    = "m3mgd_attack_weapon_type"
!mmm   set m3mgdAttrHealthGain          = "m3mgd_health_gain"
!mmm   set m3mgdAttrEnduranceGain       = "m3mgd_endurance_gain"
!mmm
!mmm   set m3mgdExchangeAttrList = m3mgdAttrAttackType, m3mgdAttrAttackerID, m3mgdAttrAttackTargetID, m3mgdAttrAttackResult, m3mgdAttrAttackDamage, m3mgdAttrAttackDamageRoll, m3mgdAttrAttackWeaponType, m3mgdAttrHealthGain, m3mgdAttrEnduranceGain
!mmm
!mmm   set m3mgdValidMeleeAttackWeaponTypes = "waffenlos", "Einhandschwert", "Zweihandschwert", "Fechtwaffe", "Stichwaffe", "Stockwaffe", "Spießwaffe", "Kettenwaffe", "Einhandschlagwaffe", "Zweihandschlagwaffe", "Zauberstab"
!mmm   set m3mgdValidRangedAttackWeaponTypes = "Bogen", "Kurzbogen", "Langbogen", "Kompositbogen", "schwere Armbrust", "leichte Armbrust", "Handarmbrust", "Schleuder", "Blasrohr", "Wurfspieß", "Wurfscheibe", "Wurfklinge", "Stielwurfwaffe"
!mmm   set m3mgdValidAttackWeaponTypes = m3mgdValidMeleeAttackWeaponTypes, m3mgdValidRangedAttackWeaponTypes
!mmm
!mmm   set m3mgdArmorPiercingWeaponTypes = "Langbogen", "Kompositbogen", "schwere Armbrust", "Schwere Armbrust"
!mmm
!mmm   set m3mgdParryLargeShieldTypes = "großer Schild", "Großer Schild"
!mmm   set m3mgdParrySmallShieldTypes = "kleiner Schild", "Kleiner Schild"
!mmm   set m3mgdParrySmallShieldEffectiveAgainst = "Einhandschlagwaffe", "Einhandschwert", "Fechtwaffe", "Kettenwaffe", "Spießwaffe", "Stichwaffe", "Stockwaffe", "Zauberstab", "waffenlos"
!mmm   set m3mgdParryStandardTypes = "Buckler", "Parierdolch", "Kampfgabeln"
!mmm   set m3mgdParryStandardEffectiveAgainst = "Einhandschwert", "Fechtwaffe", "Spießwaffe", "Stichwaffe", "Stockwaffe", "Zauberstab", "Buckler", "Parierdolch", "Kampfgabeln", "waffenlos"
!mmm
!mmm   set m3mgdInjuryStatus = { "green": { "rollModifiers": {"meleeAttack": -4, "rangedAttack": -4, "defense": -4 }, "label": "Erschöpft", "icon": "🟢", "desc": "alles -4" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "yellow": { "label": "Schwer verwundet", "icon": "🟡", "desc": "Ausdauer begrenzt auf 50%" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "red": { "noAttack": true, "noDefense": true, "label": "Handlungsunfähig", "icon": "🔴", "desc": "B=4, PW:Kon nach 10min, sonst Schock" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "brown": { "noAttack": true, "noDefense": true, "label": "Schock", "icon": "🟤", "desc": "Keine Angriffe oder Abwehr" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "death_zone": { "noAttack": true, "noDefense": true, "label": "Dem Tode nah", "icon": "💀", "desc": "B=0, PW:Kon nach 10min, sonst Schock" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "ninja_mask": { "noAttack": true, "noDefense": true, "label": "Schwere Kopfverletzung", "icon": "", "desc": "Keine Angriffe oder Abwehr" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "back_pain": { "combatRoundEffects": { "death": 10 }, "label": "Schwere Halswirbelverletzung", "icon": "", "desc": "10% Sterberisiko pro Kampfrunde" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "sleepy": { "combatRoundEffects": { "health": -1, "endurance": -1 }, "label": "Schwere Halsverletzung", "icon": "", "desc": "-1 LP/AP pro Kampfrunde" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "grab": { "rollModifiers": { "meleeAttack": -4, "rangedAttack": -4, "defense": -4 }, "label": "Arm schwer verletzt", "icon": "", "desc": "alles -4 (falsche Hand)" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "tread": { "rollModifiers": { "defense": -4 }, "label": "Bein schwer verletzt", "icon": "", "desc": "Abwehr -4" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "bleeding_eye": { "rollModifiers": { "Sehen": -2 }, "label": "Augen schwer verletzt", "icon": "", "desc": "Sehen -2" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "screaming": { "rollModifiers": { "Hören": -2 }, "label": "Ohren schwer verletzt", "icon": "", "desc": "Hören -2" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "broken_heart": { "noAttack": true, "noDefense": true, "label": "Schwere innere Verletzung", "icon": "", "desc": "Keine Angriffe oder Abwehr" } }
!mmm   set m3mgdInjuryStatus = { m3mgdInjuryStatus, "white_tower": { "rollModifiers": { "meleeAttack": -4, "rangedAttack": -4, "defense": -4 }, "label": "Rippen schwer verletzt", "icon": "", "desc": "alles -4" } }
!mmm
!mmm   if not m3mgdCriticalEffectsTable
!mmm     if "MacroSheet".m3mgdCriticalEffectsTable ne ""
!mmm       set m3mgdCriticalEffectsTable = deserialize("MacroSheet".m3mgdCriticalEffectsTable)
!mmm       publish to game: m3mgdCriticalEffectsTable
!mmm     else
!mmm       chat: **Tabelle der kritischen Kampfereignisse fehlt, bitte neu anlegen.**
!mmm     end if
!mmm   end if
!mmm
!mmm   if isunknown(m3mgdExchange.m3mgdActivePersistentEffects) or m3mgdExchange.m3mgdActivePersistentEffects eq ""
!mmm     do setattr(m3mgdExchange, "m3mgdActivePersistentEffects", serialize({}))
!mmm   end if
!mmm   
!mmm   set m3mgdAttrXP = "Erfahrungsschatz"
!mmm   set m3mgdAttrXPLog = "Erfahrungsprotokoll"
!mmm
!mmm   publish to game: m3mgdScriptCommands, m3mgdExchange
!mmm   publish to game: m3mgdAttrAttackType, m3mgdAttrAttackerID, m3mgdAttrAttackTargetID, m3mgdAttrAttackResult, m3mgdAttrAttackDamage, m3mgdAttrAttackDamageRoll, m3mgdAttrAttackWeaponType
!mmm   publish to game: m3mgdAttrHealthGain, m3mgdAttrEnduranceGain
!mmm   publish to game: m3mgdExchangeAttrList
!mmm   publish to game: m3mgdValidAttackWeaponTypes, m3mgdValidMeleeAttackWeaponTypes, m3mgdValidRangedAttackWeaponTypes
!mmm   publish to game: m3mgdArmorPiercingWeaponTypes
!mmm   publish to game: m3mgdParryLargeShieldTypes, m3mgdParrySmallShieldTypes, m3mgdParrySmallShieldEffectiveAgainst, m3mgdParryStandardTypes, m3mgdParryStandardEffectiveAgainst
!mmm   publish to game: m3mgdInjuryStatus, m3mgdAttrXP, m3mgdAttrXPLog
!mmm
!rem   // Publish game-global functions defined below
!rem
!mmm   publish to game: m3mgdValidateOwnTokenID, m3mgdValidateTokenAttribute
!mmm   publish to game: m3mgdGetEnduranceAttribute, m3mgdGetHealthAttribute
!mmm   publish to game: m3mgdValidateAttackData, _m3mgdExecuteCode, m3mgdRollChanceEffect, m3mgdFlushExchange
!mmm   publish to game: _m3mgdGetStoredAttr, m3mgdSetAttrCeiling, m3mgdAttrCeiling, m3mgdReleaseAttrCeiling
!mmm   publish to game: m3mgdHasActivePersistentEffects, m3mgdGetActivePersistentEffects
!mmm   publish to game: m3mgdActiveStatusModifiers, m3mgdIsExhausted, m3mgdIsDefenseless, m3mgdIsUnfitToAttack
!mmm   publish to game: m3mgdShapeMoji, m3mgdEnduranceStatusLabel, m3mgdEnduranceStatusEffectsDesc
!mmm   publish to game: m3mgdHealthStatusLabel, m3mgdHealthStatusEffectsDesc
!mmm   publish to game: m3mgdModifyEndurance, m3mgdModifyHealth, m3mgdProcessInjury
!mmm   publish to game: m3mgdGetTokenDirection, m3mgdGetViewAngle, m3mgdGetDistance, m3mgdMoveToken, m3mgdSpawnWeaponToken
!mmm   publish to game: m3mgdExchangeStoreAttack, m3mgdExchangeStoreHealthBoost, m3mgdExchangeStoreEnduranceBoost
!mmm   publish to game: m3mgdListDefenseWeapons, m3mgdListMeleeAttackWeapons, m3mgdListRangedAttackWeapons
!mmm   publish to game: m3mgdDefenseWeaponType, m3mgdMeleeWeaponType, m3mgdRangedWeaponProperties
!mmm   publish to game: _m3mgdWeaponButtonPayload, m3mgdWeaponSelectorChatMenu, m3mgdRerunButton
!mmm   publish to game: m3mgdDefenseDataEntryPayload, m3mgdDefenseInitPayload, m3mgdDefenseDataTable, m3mgdChatDefensePrompt
!mmm   publish to game: m3mgdWeaponSpecialEffect, m3mgdInjuryFX, m3mgdEffectiveArmorProtection
!mmm   publish to game: m3mgdGetCriticalEffect, m3mgdStorePersistentEffect, m3mgdExecuteCriticalEffect
!mmm   publish to game: m3mgdCriticalEffectPrompt, m3mgdCriticalEffectRollPayload, m3mgdUpdatePersistentEffectsCounters
!mmm   publish to game: m3mgdProcessCombatPP, m3mgdProcessAttackXP
!mmm
!mmm   chat: ${libVersion} loaded.
!mmm   
!mmm end function
!rem
!rem // m3mgdValidateOwnTokenID(tokenID)
!rem // 
!rem //   Validates tokenID or pulls script.cOwnID as a default, checks for reading access.
!rem //   Returns the ID or false in case of validation or access issues.
!rem // 
!mmm function m3mgdValidateOwnTokenID(tokenID)
!mmm   if isdefault(tokenID)
!mmm     set id = script.cOwnID.token_id
!mmm   else
!mmm     set id = tokenID.token_id
!mmm   end if
!mmm 
!mmm   if isunknown(id) or isdenied(id)
!mmm     return false
!mmm   end if
!mmm 
!mmm   return id 
!mmm 
!mmm end function
!rem
!rem // m3mgdValidateTokenAttribute(tokenID, attrLabel, [defaultAttrLabel])
!rem // 
!rem //   Validates attrLabel or, if set to default, defaultAttrLabel, as a readable attribute of tokenID.
!rem //   Returns the attrLabel value found valid or false in case of validation or access issues.
!rem // 
!mmm function m3mgdValidateTokenAttribute(tokenID, attrLabel, defaultAttrLabel)
!mmm 
!mmm   if isunknown(tokenID.(attrLabel)) or isdenied(tokenID.(attrLabel))
!mmm     
!mmm     if isdefault(defaultAttrLabel) or isunknown(tokenID.(script.(defaultAttrLabel))) or isdenied(tokenID.(script.(defaultAttrLabel)))
!mmm     
!mmm       return false
!mmm     
!mmm     else
!mmm     
!mmm       return script.(defaultAttrLabel)
!mmm     
!mmm     end if
!mmm     
!mmm   else
!mmm   
!mmm     return attrLabel
!mmm 
!mmm   end if
!mmm   
!mmm end function
!rem
!rem // m3mgdGetEnduranceAttribute(tokenID)
!rem //
!rem //   Returns name of a valid, preferred attribute to access the token's endurance.
!rem // 
!mmm function m3mgdGetEnduranceAttribute(tokenID)
!mmm   if m3mgdValidateTokenAttribute(tokenID, script.cEnduranceAttr)
!mmm     return script.cEnduranceAttr
!mmm   else if tokenID.PC
!mmm     return m3mgdValidateTokenAttribute(tokenID, "AP")
!mmm   else
!mmm     return m3mgdValidateTokenAttribute(tokenID, "bar2")
!mmm   end if
!mmm end function
!rem
!rem // m3mgdGetHealthAttr(tokenID)
!rem //
!rem //   Returns name of a valid, preferred attribute to access the token's health.
!rem // 
!mmm function m3mgdGetHealthAttribute(tokenID)
!mmm   if m3mgdValidateTokenAttribute(tokenID, script.cHealthAttr)
!mmm     return script.cHealthAttr
!mmm   else if tokenID.PC
!mmm     return m3mgdValidateTokenAttribute(tokenID, "LP")
!mmm   else
!mmm     return m3mgdValidateTokenAttribute(tokenID, "bar3")
!mmm   end if
!mmm end function
!rem
!rem // m3mgdValidateAttackData([dataExchangeID])
!rem // 
!rem //   Expects a global data exchange character sheet as m3mgdExchange or as an argument.
!rem //   Validates attack data stack within that sheet and returns true/false.
!rem // 
!mmm function m3mgdValidateAttackData(dataExchangeID)
!mmm
!mmm   if isdefault(dataExchangeID)
!mmm     set dataExchangeID = m3mgdExchange
!mmm   end if
!mmm   if isunknown(dataExchangeID) or isdenied(dataExchangeID)
!mmm     do whisperback("Invalid attack data exchange sheet: " & getreason(dataExchangeID))
!mmm     return false
!mmm   end if
!mmm
!mmm   set validItems = 0
!mmm   if dataExchangeID.(m3mgdAttrAttackTargetID).token_id
!mmm     set validItems = validItems + 1
!mmm   end if
!mmm   if dataExchangeID.(m3mgdAttrAttackType) eq "melee" or dataExchangeID.(m3mgdAttrAttackType) eq "ranged"
!mmm     set validItems = validItems + 1
!mmm   end if
!mmm   if dataExchangeID.(m3mgdAttrAttackResult) >= 20
!mmm     set validItems = validItems + 1
!mmm   end if
!mmm   if dataExchangeID.(m3mgdAttrAttackResult).max eq "true" or dataExchangeID.(m3mgdAttrAttackResult).max eq "false"
!mmm     set validItems = validItems + 1
!mmm   end if
!mmm   if not isunknown(dataExchangeID.(m3mgdAttrAttackDamage)) and dataExchangeID.(m3mgdAttrAttackDamage) >= 0
!mmm     set validItems = validItems + 1
!mmm   end if
!mmm   if not isunknown(dataExchangeID.(m3mgdAttrAttackDamageRoll)) and dataExchangeID.(m3mgdAttrAttackDamageRoll) >= 0
!mmm     set validItems = validItems + 1
!mmm   end if
!mmm   if not isunknown(dataExchangeID.(m3mgdAttrAttackWeaponType))
!mmm     if dataExchangeID.(m3mgdAttrAttackWeaponType).max ne "" 
!mmm       set validItems = validItems + 1
!mmm     else if dataExchangeID.(m3mgdAttrAttackType) eq "melee" 
!mmm       if m3mgdValidMeleeAttackWeaponTypes where ... eq dataExchangeID.(m3mgdAttrAttackWeaponType)
!mmm         set validItems = validItems + 1
!mmm       else
!mmm         do whisperback("Invalid melee attack weapon type: " & dataExchangeID.(m3mgdAttrAttackWeaponType) & " is none of " & m3mgdValidMeleeAttackWeaponTypes)
!mmm       end if
!mmm     else if dataExchangeID.(m3mgdAttrAttackType) eq "ranged" 
!mmm       if m3mgdValidRangedAttackWeaponTypes where ... eq dataExchangeID.(m3mgdAttrAttackWeaponType)
!mmm         set validItems = validItems + 1
!mmm       else
!mmm         do whisperback("Invalid range attack weapon type: " & dataExchangeID.(m3mgdAttrAttackWeaponType) & " is none of " & m3mgdValidRangedAttackWeaponTypes)
!mmm       end if
!mmm     end if
!mmm   end if 
!mmm
!mmm   return (validItems == 7)
!mmm
!mmm end function
!rem
!rem // _m3mgdExecuteCode(codeLines, myID, foeID)
!rem // 
!rem //   Internal. Expects a line or list of lines ready to be piped to the chat (so "!mmm " is required!).
!rem //   Variables myID and foeID are published to the sender, so they are available to the dynamic code.
!rem // 
!mmm function _m3mgdExecuteCode(codeLines, myID, foeID)
!mmm   publish to sender: myID, foeID
!mmm   for codeLine in codeLines 
!mmm     chat: ${codeLine}
!mmm   end for
!mmm end function
!rem
!rem // m3mgdRollChanceEffect(tokenID, attribute, rollTemplate, rollModifiers, immediateEffect, [persistentEffect])
!rem // 
!rem //   If a rollTemplate roll exceeds tokenID.(attribute)+rollModifiers, executes Roll20 chat code immediateEffect and stores persistentEffect.
!rem // 
!mmm function m3mgdRollChanceEffect(tokenID, attribute, rollTemplate, rollModifiers, immediateEffect, persistentEffect)
!mmm
!rem   // Stop condition if recursion ends up here without a tokenID
!mmm   if isdefault(tokenID) or isunknown(tokenID)
!mmm     return false
!mmm   end if
!mmm
!mmm   combine chat
!mmm
!mmm     chat: ${"&"}{template:default} 
!mmm     if attribute + 0 eq attribute 
!mmm       chat: {\{name=${tokenID.name}: Zufallseffekt}\}
!mmm     else
!mmm       chat: {\{name=${tokenID.name}: Prüfwurf${sign(rollModifiers, "math")} gegen ${attribute} }\}
!mmm     end if
!mmm 
!mmm     set rollResult = roll(rollTemplate & sign(rollModifiers, "math"))
!mmm 
!mmm     if rollResult > tokenID.(attribute)
!mmm       chat: {\{ 🎲 = ${rollResult}: Effekt tritt ein (${literal(immediateEffect)}) }\}
!mmm     else 
!mmm       chat: {\{ 🎲 = ${rollResult}: Effekt tritt **nicht** ein }\}
!mmm     end if
!mmm
!mmm   end combine
!mmm
!mmm   if rollResult > tokenID.(attribute)
!mmm     do _m3mgdExecuteCode(immediateEffect, tokenID)
!mmm     if not isdefault(persistentEffect)
!mmm       do m3mgdStorePersistentEffect(tokenID, { label: currentEffect.label, desc: currentEffect.desc, effect: persistentEffect })
!mmm     end if
!mmm   end if
!mmm
!mmm end function
!rem
!rem // m3mgdFlushExchange([dataExchangeID], [attrList])
!rem // 
!rem //   Expects a global data exchange character sheet as m3mgdExchange or as an argument
!rem //   Returns the number of attributes set to "" in both their current and max values
!rem // 
!mmm function m3mgdFlushExchange(dataExchangeID, attrList)
!mmm
!mmm   if isdefault(dataExchangeID)
!mmm     set dataExchangeID = m3mgdExchange
!mmm   end if
!mmm   if isdefault(attrList)
!mmm     set attrList = m3mgdExchangeAttrList
!mmm   end if 
!mmm
!mmm   set flushedCounter = 0
!mmm   for attribute in attrList
!mmm     do setattr(dataExchangeID, attribute, "")
!mmm     do setattrmax(dataExchangeID, attribute, "")
!mmm     set flushedCounter = flushedCounter + 1
!mmm   end for
!mmm
!mmm   return flushedCounter
!mmm 
!mmm end function
!rem 
!rem // m3mgdSetAttrCeiling(tokenID, attrLabel, ceilingValue)
!rem // 
!rem //   Places a temporary ceiling ceilingValue on tokenID attribute attrLabel and saves its value to be restored by m3mgdReleaseAttrCeiling().
!rem //
!mmm function m3mgdSetAttrCeiling(tokenID, attrLabel, ceilingValue)
!mmm
!mmm   set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   
!mmm   if isdefault(attrLabel) or isunknown(tokenID.(attrLabel)) or isdenied(tokenID.(attrLabel))
!mmm     do whisperback("m3mgdSetAttrCeiling(): '" & attrLabel & "' is no valid attribute for token '" & tokenID.name & "'")
!mmm     return false
!mmm   end if
!mmm   
!mmm   if isdefault(ceilingValue)
!mmm     set ceilingValue = tokenID.(attrLabel)
!mmm   end if
!mmm   
!mmm   set dataExchangeID = m3mgdExchange
!mmm   
!mmm   set storageAttrLabel = "m3mgd_tokenAttrCeiling" & tokenID & "_" & attrLabel
!rem   // Roll20 attributes are always strings, so string comparison theoretically allows for non-numerical "ceilings"
!mmm   if setattr(dataExchangeID, storageAttrLabel, ceilingValue) eq ceilingValue
!mmm     
!rem     // If current attribute value exceeds the ceiling, bring it down
!mmm     if tokenID.(attrLabel) > ceilingValue
!mmm     
!mmm       if setattr(tokenID, attrLabel, ceilingValue) == ceilingValue
!mmm     
!mmm         return ceilingValue
!mmm     
!mmm       else 
!mmm     
!mmm         do whisperback("m3mgdSetAttrCeiling(): Failure changing '" & tokenID.name & "'.'" & attrLabel & "' to '" & ceilingValue & "'.")
!mmm         return false
!mmm
!mmm       end if
!mmm
!mmm     else 
!mmm     
!mmm       return ceilingValue
!mmm     
!mmm     end if
!mmm     
!mmm   else
!mmm   
!mmm     do whisperback("m3mgdSetAttrCeiling(): Failure setting " & ceilingValue & " as ceiling for '" & tokenID.name & "'.'" & attrLabel & "'.")
!mmm     return false
!mmm
!mmm   end if
!mmm   
!mmm end function
!rem
!rem // _m3mgdGetStoredAttr(dataExchangeID, tokenID, attrLabel, [flushStoredAttr])
!rem // 
!rem //   Pulls stored attribute attrLabel for tokenID from data exchange stack and guesses between alternative endurance attributes.
!rem //   If flushStoredAttr == true, resets the stored attribute to "".
!rem //
!mmm function _m3mgdGetStoredAttr(dataExchangeID, tokenID, attrLabel, flushStoredAttr)
!mmm   set paramAttrLabel = attrLabel
!mmm   set storageAttrLabel = "m3mgd_tokenAttrCeiling" & tokenID & "_" & attrLabel
!mmm   if isunknown(dataExchangeID.(storageAttrLabel))
!rem     // Ugly guess for endurance being stored in either "AP" or "bar2": try the other
!mmm     if attrLabel eq "AP" or attrLabel eq "bar2"
!mmm       if attrLabel eq "AP"
!mmm         set attrLabel = "bar2"
!mmm       else if attrLabel eq "bar2"
!mmm         set attrLabel = "AP"
!mmm       end if
!mmm       set storageAttrLabel = "m3mgd_tokenAttrCeiling" & tokenID & "_" & attrLabel
!mmm     end if
!mmm     if isunknown(dataExchangeID.(storageAttrLabel))
!mmm       return false
!mmm     end if
!mmm   end if
!mmm   set payload = dataExchangeID.(storageAttrLabel)
!mmm   if flushStoredAttr
!mmm     do setattr(dataExchangeID, storageAttrLabel, "")
!mmm   end if
!mmm   return payload
!mmm end function
!rem
!rem // m3mgdAttrCeiling(tokenID, attrLabel)
!rem // 
!rem //   Returns tokenID's temporary ceiling placed on attribute attrLabel, if present, otherwise false.
!rem //
!mmm function m3mgdAttrCeiling(tokenID, attrLabel)
!mmm   
!mmm   set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   
!mmm   if isdefault(attrLabel) or isunknown(tokenID.(attrLabel)) or isdenied(tokenID.(attrLabel))
!mmm     do whisperback("m3mgdAttrCeiling(): '" & attrLabel & "' is no valid attribute for token '" & tokenID.name & "'")
!mmm     return false
!mmm   end if
!mmm
!mmm   set attrCeiling = _m3mgdGetStoredAttr(m3mgdExchange, tokenID, attrLabel)
!mmm   if attrCeiling > 0
!mmm     return attrCeiling
!mmm   else
!mmm     return false
!mmm   end if
!mmm   
!mmm end function
!rem
!rem // m3mgdReleaseAttrCeiling(tokenID, attrLabel)
!rem // 
!rem //   Releases a temporary ceiling placed on tokenID attribute attrLabel by m3mgdSetAttrCeiling() and restores the saved value for it.
!rem //
!mmm function m3mgdReleaseAttrCeiling(tokenID, attrLabel)
!mmm   
!mmm   set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   
!mmm   if isdefault(attrLabel) or isunknown(tokenID.(attrLabel)) or isdenied(tokenID.(attrLabel))
!mmm     do whisperback("m3mgdReleaseAttrCeiling(): '" & attrLabel & "' is no valid attribute for token '" & tokenID.name & "'")
!mmm     return false
!mmm   end if
!mmm   
!mmm   set dataExchangeID = m3mgdExchange
!mmm   
!mmm   set flushStoredAttr = true
!mmm   set ceilingValue = _m3mgdGetStoredAttr(dataExchangeID, tokenID, attrLabel, flushStoredAttr)
!mmm   if ceilingValue == false or ceilingValue < 0 or (tokenID.(attrLabel).max > 0 and ceilingValue > tokenID.(attrLabel).max)
!mmm   
!mmm     do whisperback("m3mgdReleaseAttrCeiling(): ceiling for '" & tokenID.name & "'.'" & attrLabel & "' is missing or invalid ('" & ceilingValue & "').")
!mmm     return false
!mmm   
!mmm   end if
!mmm   
!mmm   return true
!mmm   
!mmm end function
!rem
!rem // m3mgdHasActivePersistentEffects(tokenID)
!rem //
!rem //   Returns true if tokenID has active persistent effects registered, otherwise false.
!rem //
!mmm function m3mgdHasActivePersistentEffects(tokenID)
!mmm   return (not isunknown((deserialize(m3mgdExchange.m3mgdActivePersistentEffects)).(tokenID)))
!mmm end function
!rem
!rem // m3mgdGetActivePersistentEffects(tokenID)
!rem //
!rem //   Returns a list of tokenID's active persistent effects.
!rem //
!mmm function m3mgdGetActivePersistentEffects(tokenID)
!mmm   return deserialize(m3mgdExchange.m3mgdActivePersistentEffects).(tokenID)
!mmm end function
!rem
!rem // m3mgdActiveStatusModifiers(tokenID, action)
!rem //
!rem //   Returns a list of tokenID's active status modifiers from severe injuries or critical effects for a given action (defense, meleeAttack, see, hear etc.).
!rem //
!mmm function m3mgdActiveStatusModifiers(tokenID, action)
!mmm
!mmm   if isdefault(tokenID)
!mmm     set tokenID = m3mgdValidateOwnTokenID(script.cOwnID)
!mmm   else
!mmm     set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   end if
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   if not m3mgdHasActivePersistentEffects(tokenID)
!mmm     set tokenActiveEffectsList = m3mgdGetActivePersistentEffects(tokenID)
!mmm   end if
!mmm 
!mmm   for statusModRule in m3mgdInjuryStatus... where tokenID.("status_" & ...key) eq "shown"
!mmm     if statusModRule.value.rollModifiers.(action) and count(statusModRule.value.excluded where ...token_id eq tokenID) == 0
!mmm       set activeStatusModifiers = activeStatusModifiers, { marker: statusModRule.key, statusModRule.value... }
!mmm     end if
!mmm     if statusModRule.value.(action)
!mmm       set activeStatusModifiers = activeStatusModifiers, { marker: statusModRule.key, statusModRule.value... }
!mmm     end if
!mmm   end for
!mmm   
!mmm   for statusModRule in tokenActiveEffectsList
!mmm     if statusModRule.effect.(action) or statusModRule.effect.rollModifiers.(action)
!mmm       set activeStatusModifiers = activeStatusModifiers, { label: statusModRule.label, desc: statusModRule.desc, statusModRule.effect... }
!mmm     end if
!mmm   end for
!mmm
!mmm   return activeStatusModifiers
!mmm
!mmm end function
!rem
!rem // m3mgdIsExhausted(tokenID)
!rem //
!rem // Returns true if tokenID is exhausted (endurance is 0).
!rem //
!mmm function m3mgdIsExhausted(tokenID)
!mmm   if isdefault(tokenID)
!mmm     set tokenID = m3mgdValidateOwnTokenID(script.cOwnID)
!mmm   else
!mmm     set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   end if
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   return (tokenID.(m3mgdGetEnduranceAttribute(tokenID)).max > 0 and tokenID.(m3mgdGetEnduranceAttribute(tokenID)) <= 0)
!mmm end function
!rem
!rem // m3mgdIsDefenseless(tokenID, [healthAttr])
!rem //
!rem // Returns an m3mgdInjuryStatus struct if tokenID is defenseless.
!rem // If healthAttr is not provided, the check defaults to script.cHealthAttr.
!rem //
!mmm function m3mgdIsDefenseless(tokenID, healthAttr)
!mmm
!mmm   set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   if not tokenID
!mmm     return unknown
!mmm   end if
!mmm   if isdefault(healthAttr)
!mmm     set healthAttr = m3mgdGetHealthAttribute(tokenID)
!mmm   end if
!mmm
!mmm   set defenselessStatus = m3mgdActiveStatusModifiers(tokenID, "noDefense")
!mmm   if defenselessStatus
!mmm     return defenselessStatus
!mmm   else if not tokenID.(healthAttr).max == 0 and tokenID.(healthAttr) <= 3
!mmm     return m3mgdInjuryStatus.red
!mmm   else
!mmm     return false
!mmm   end if
!mmm
!mmm end function
!rem
!rem // m3mgdIsUnfitToAttack(tokenID)
!rem // 
!rem //   Returns true (and outputs the reasons to the chat) if tokenID is unable to attack. Otherwise returns false.
!rem // 
!mmm function m3mgdIsUnfitToAttack(tokenID)
!mmm
!mmm   set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   if not tokenID
!mmm     return unknown
!mmm   end if
!mmm
!mmm   set noAttackStatusList = m3mgdActiveStatusModifiers(tokenID, "noAttack")
!mmm   if noAttackStatusList
!mmm     combine chat
!mmm       if script.cGMSilentMode
!mmm         chat: /w GM 
!mmm       end if
!mmm       chat: ${"&"}{template:default} {\{name=${tokenID.name}: Angriff nicht möglich }\}
!mmm       for reason in noAttackStatusList
!mmm         set counter = counter + 1
!mmm         if reason.expiry
!mmm           chat: {\{ #${counter} (noch ${reason.expiry.count} ${reason.expiry.type})=${reason.label}: ${reason.desc} }\}
!mmm         else
!mmm           chat: {\{ #${counter}=${reason.label}: ${reason.desc}  }\}
!mmm         end if
!mmm       end for
!mmm       set endOfActionSummary = m3mgdUpdatePersistentEffectsCounters(tokenID, "attack")
!mmm       if endOfActionSummary
!mmm         chat: {\{ Angriff beendet=${endOfActionSummary} }\}
!mmm       end if
!mmm     end combine
!mmm     return true
!mmm   end if
!mmm
!mmm   return false
!mmm
!mmm end function
!rem
!rem // m3mgdShapeMoji([tokenID])
!rem //
!rem // Returns visual indicator of health and exhaustion.
!rem //
!mmm function m3mgdShapeMoji(tokenID)
!mmm     
!mmm   if isdefault(tokenID)
!mmm     set tokenID = m3mgdValidateOwnTokenID(script.cOwnID)
!mmm   else
!mmm     set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   end if
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   set healthAttr = m3mgdGetHealthAttribute(tokenID)
!mmm   set enduranceAttr = m3mgdGetEnduranceAttribute(tokenID)
!mmm
!mmm   if not tokenID.(healthAttr).max == 0 and tokenID.(healthAttr) <= 0
!mmm     return highlight("💀", "bad", "Dem Tode nah... jetzt zählt jede Sekunde!")
!mmm   end if
!mmm
!mmm   set shapeMoji = ""
!mmm   if tokenID.(healthAttr).max != 0 and tokenID.(healthAttr) < .5 * tokenID.(healthAttr).max
!mmm     set shapeMoji = shapeMoji & "🤕"
!mmm   end if 
!mmm   if tokenID.(enduranceAttr).max != 0 and tokenID.(enduranceAttr) <= 0
!mmm     set shapeMoji = shapeMoji & "🥴"
!mmm   end if 
!mmm   if shapeMoji eq ""
!mmm     set shapeMoji = "😀"
!mmm   end if 
!mmm     
!mmm   return shapeMoji
!mmm     
!mmm end function
!rem 
!rem // m3mgdEnduranceStatusLabel(tokenID)
!rem // 
!mmm function m3mgdEnduranceStatusLabel(tokenID)
!mmm   
!mmm   set enduranceLabel = "🔋 "
!mmm
!mmm   if isdefault(tokenID)
!mmm     set tokenID = m3mgdValidateOwnTokenID(script.cOwnID)
!mmm   else
!mmm     set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   end if
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   
!mmm   if tokenID.status_green eq "shown"
!mmm     
!mmm     return enduranceLabel & "Erschöpft"
!mmm     
!mmm   else
!mmm     
!mmm     return enduranceLabel & "Geht noch!"
!mmm     
!mmm   end if
!mmm     
!mmm end function
!rem // 
!rem // m3mgdEnduranceStatusEffectsDesc([tokenID])
!rem // 
!mmm function m3mgdEnduranceStatusEffectsDesc(tokenID)
!mmm
!mmm   if isdefault(tokenID)
!mmm     set tokenID = m3mgdValidateOwnTokenID(script.cOwnID)
!mmm   else
!mmm     set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   end if
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   
!mmm   if tokenID.status_green eq "shown"
!mmm     
!mmm     return "🟢 -4 auf alles, max. Last reduziert"
!mmm     
!mmm   else if (tokenID.status_yellow eq "shown" or tokenID.status_red eq "shown" or tokenID.status_death_zone eq "shown") and m3mgdAttrCeiling(tokenID, m3mgdGetEnduranceAttribute(tokenID))
!mmm     
!mmm     return "🟡 Ausdauer begrenzt auf 50%"
!mmm     
!mmm   else
!mmm     
!mmm     return "keine Einschränkungen"
!mmm     
!mmm   end if
!mmm     
!mmm end function
!rem // 
!rem // m3mgdHealthStatusLabel([tokenID])
!rem // 
!mmm function m3mgdHealthStatusLabel(tokenID)
!mmm   
!mmm   set healthLabel = "⚕️ "
!mmm
!mmm   if isdefault(tokenID)
!mmm     set tokenID = m3mgdValidateOwnTokenID(script.cOwnID)
!mmm   else
!mmm     set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   end if
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   
!mmm   set healthAttr = m3mgdGetHealthAttribute(tokenID)
!mmm
!mmm   if tokenID.status_yellow eq "shown"
!mmm     
!mmm     return healthLabel & "Schwer verwundet"
!mmm     
!mmm   else if tokenID.status_red eq "shown"
!mmm     
!mmm     return healthLabel & "Extrem schwer verwundet"
!mmm     
!mmm   else if tokenID.status_death_zone eq "shown" and tokenID.(healthAttr) >= 0
!mmm     
!mmm     return healthLabel & "Dem Tode nah"
!mmm     
!mmm   else if tokenID.status_death_zone eq "shown" and tokenID.(healthAttr) < 0
!mmm     
!mmm     return healthLabel & "Im Sterben"
!mmm     
!mmm   else
!mmm     
!mmm     return healthLabel & "Soweit in Ordnung!"
!mmm     
!mmm   end if
!mmm     
!mmm end function
!rem // 
!rem // m3mgdHealthStatusEffectsDesc([tokenID])
!rem // 
!mmm function m3mgdHealthStatusEffectsDesc(tokenID)
!mmm   
!mmm   if isdefault(tokenID)
!mmm     set tokenID = m3mgdValidateOwnTokenID(script.cOwnID)
!mmm   else
!mmm     set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   end if
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   
!mmm   set healthAttr = m3mgdGetHealthAttribute(tokenID)
!mmm
!mmm   if tokenID.status_yellow eq "shown"
!mmm     
!mmm     return "🟡 max. halbe AP, halbe Bewegung"
!mmm     
!mmm   else if tokenID.status_red eq "shown"
!mmm     
!mmm     return "🔴 handlungsunfähig, B=4, PW:Kon nach 10min, sonst Schock"
!mmm     
!mmm   else if tokenID.status_death_zone eq "shown" and tokenID.(healthAttr) >= 0
!mmm     
!mmm     return "💀 handlungsunfähig, B=0, PW:Kon nach 10min, sonst Schock"
!mmm     
!mmm   else if tokenID.status_death_zone eq "shown" and tokenID.(healthAttr) < 0
!mmm     
!mmm     return "💀 **Countdown läuft**"
!mmm     
!mmm   else
!mmm     
!mmm     return "keine Einschränkungen"
!mmm     
!mmm   end if
!mmm     
!mmm end function
!rem // 
!rem // m3mgdModifyEndurance(offset, [tokenID], [enduranceAttr])
!rem // 
!rem // Modifies [tokenID's] or script.cOwnID's endurance by offset points. For a loss, offset is negative.
!rem // Uses script.cEnduranceAttr to access endurance if no enduranceAttr is specified.
!rem // Returns the new level of endurance.
!rem //
!mmm function m3mgdModifyEndurance(offset, tokenID, enduranceAttr)
!mmm   
!mmm   set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm
!mmm   set enduranceAttr = m3mgdValidateTokenAttribute(tokenID, enduranceAttr, "cEnduranceAttr")
!mmm   if not enduranceAttr
!mmm     set enduranceAttr = m3mgdGetEnduranceAttribute(tokenID)
!mmm   end if
!mmm   
!mmm   set prvEndurance = tokenID.(enduranceAttr)
!mmm   set maxEndurance = tokenID.(enduranceAttr).max
!mmm
!rem   // Check if character is actually alive
!mmm
!mmm   if maxEndurance == 0
!mmm
!rem     // tokenID (AP.max=0) cannot win or lose endurance
!mmm     return highlight(prvEndurance, "normal", "unverändert")
!mmm
!mmm   end if
!mmm
!mmm   set currentCeiling = m3mgdAttrCeiling(tokenID, enduranceAttr)
!mmm   set newEndurance = false
!mmm
!rem   // Process change of endurance and applicable consequences 
!mmm
!mmm   if currentCeiling and prvEndurance + offset > currentCeiling
!mmm     set effOffset = highlight(sign(currentCeiling - prvEndurance, "display"), "important", "begrenzt auf " & currentCeiling)
!mmm   else if prvEndurance + offset > maxEndurance
!mmm     set effOffset = highlight(sign(maxEndurance - prvEndurance, "display"), "important", "begrenzt auf Maximum")
!mmm   else if prvEndurance + offset <= 0
!mmm     set effOffset = highlight(sign(0 - prvEndurance, "display"), "bad", "begrenzt auf Minimum 0")
!mmm   else
!mmm     set effOffset = highlight(sign(offset), "normal")
!mmm   end if 
!mmm   
!mmm   set newEndurance = prvEndurance + effOffset
!mmm   
!mmm   if newEndurance == maxEndurance
!mmm   
!mmm     set newEndurance = highlight(newEndurance, "good", "Bin sowas von topfit! (= " & prvEndurance & effOffset & ")")
!mmm     do setattr(tokenID, "status_green", false)
!mmm   
!mmm   else if currentCeiling and newEndurance == currentCeiling and newEndurance > 0
!mmm   
!mmm     set newEndurance = highlight(newEndurance, "important", "🟡 (= " & prvEndurance & effOffset & ")")
!mmm     do setattr(tokenID, "status_green", false)
!mmm   
!mmm   else if newEndurance == 0
!mmm   
!mmm     set newEndurance = highlight(newEndurance, "bad", "🟢 (= " & prvEndurance & effOffset & ")")
!mmm     do setattr(tokenID, "status_green", true)
!mmm   
!mmm   else
!mmm   
!mmm     set newEndurance = highlight(newEndurance, "normal", "Och, das bisschen Schweiß! (= " & prvEndurance & effOffset & ")")
!mmm     do setattr(tokenID, "status_green", false)
!mmm   
!mmm   end if
!mmm   
!mmm   if setattr(tokenID, enduranceAttr, newEndurance) == newEndurance
!mmm   
!mmm     return newEndurance
!mmm     
!mmm   else 
!mmm     
!mmm     do whisperback("Error writing changes to endurance (" & effOffset & ") into " & tokenID & "." & enduranceAttr)
!mmm     return false
!mmm     
!mmm   end if
!mmm   
!mmm end function
!rem 
!rem // m3mgdModifyHealth(offset, [tokenID], [healthAttr])
!rem // 
!rem // Modifies [tokenID's] or script.cOwnID's health by offset points. For a loss, offset is negative.
!rem // Uses script.cHealthAttr to access health points if no healthAttr is specified.
!rem // Returns the new level of health.
!rem //
!mmm function m3mgdModifyHealth(offset, tokenID, healthAttr)
!mmm
!mmm   if isdefault(offset)
!mmm     return false
!mmm   end if
!mmm
!mmm   set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   if not tokenID
!mmm     return false
!mmm   end if
!mmm   
!mmm   set healthAttr = m3mgdValidateTokenAttribute(tokenID, healthAttr, "cHealthAttr")
!mmm   if not healthAttr
!mmm     set healthAttr = m3mgdGetHealthAttribute(tokenID)
!mmm   end if
!mmm   
!rem   // Check if character is actually alive
!mmm
!mmm   set prvHealth = tokenID.(healthAttr)
!mmm   set maxHealth = tokenID.(healthAttr).max
!mmm
!mmm   if maxHealth == 0
!mmm
!rem     // tokenID (LP.max=0) is not alive (possibly undead), so it cannot be healed or injured
!mmm     return highlight(prvHealth, "normal", "unverändert")
!mmm
!mmm   else
!mmm
!rem     // Process health gain and applicable consequences 
!mmm
!mmm     if prvHealth + offset > maxHealth
!mmm       set effOffset = highlight(sign(maxHealth - prvHealth, "display"), "important", "begrenzt auf Maximum")
!mmm     else if prvHealth + offset <= 0
!mmm       set effOffset = highlight(sign(offset, "display"), "bad")
!mmm     else
!mmm       set effOffset = highlight(sign(offset, "display"), "normal")
!mmm     end if 
!mmm   
!mmm     set newHealth = prvHealth + effOffset
!mmm   
!mmm     if newHealth == maxHealth
!mmm   
!mmm       set newHealth = highlight(newHealth, "good", "💪 kerngesund! (= " & prvHealth & effOffset & ")")
!mmm       do setattr(tokenID, "status_death_zone", false)
!mmm       do setattr(tokenID, "status_red", false)
!mmm       do setattr(tokenID, "status_yellow", false)
!mmm   
!mmm     else if newHealth <= 0
!mmm   
!mmm       set newHealth = highlight(newHealth, "bad", "💀 (fast) tot (= " & prvHealth & effOffset & ")")
!mmm       do setattr(tokenID, "status_death_zone", true)
!mmm       do setattr(tokenID, "status_red", false)
!mmm       do setattr(tokenID, "status_yellow", false)
!mmm   
!mmm     else if newHealth <= 3
!mmm   
!rem       // Health <= 3: Red token marker => no actions, movement reduced to 4, 10-minute countdown to shock
!mmm       set newHealth = highlight(newHealth, "bad", "🔴 sehr schwer verletzt (= " & prvHealth & effOffset & ")")
!mmm       do setattr(tokenID, "status_death_zone", false)
!mmm       do setattr(tokenID, "status_red", true)
!mmm       do setattr(tokenID, "status_yellow", false)
!mmm   
!mmm     else if newHealth <= .5 * maxHealth
!mmm   
!rem       // Health <= 50%: Yellow token marker => endurance and movement to be limited to 50%
!mmm       set newHealth = highlight(newHealth, "important", "🟡 schwer verletzt (= " & prvHealth & effOffset & ")")
!mmm       do setattr(tokenID, "status_death_zone", false)
!mmm       do setattr(tokenID, "status_red", false)
!mmm       do setattr(tokenID, "status_yellow", true)
!mmm   
!mmm     else
!mmm   
!mmm       set newHealth = highlight(newHealth, "normal", "Nur ein paar Kratzer! (= " & prvHealth & effOffset & ")")
!mmm       do setattr(tokenID, "status_death_zone", false)
!mmm       do setattr(tokenID, "status_red", false)
!mmm       do setattr(tokenID, "status_yellow", false)
!mmm   
!mmm     end if
!mmm   
!mmm     if setattr(tokenID, healthAttr, newHealth) == newHealth
!mmm       
!mmm       set enduranceAttr = m3mgdValidateTokenAttribute(tokenID, default, "cEnduranceAttr")
!mmm
!mmm       if tokenID.(enduranceAttr).max > 0
!mmm
!mmm         if prvHealth > .5 * maxHealth and newHealth <= .5 * maxHealth
!mmm         
!mmm           set enduranceCeiling = round(.5 * tokenID.(enduranceAttr).max)
!mmm           do m3mgdSetAttrCeiling(tokenID, enduranceAttr, enduranceCeiling)
!mmm         
!mmm         else if prvHealth <= .5 * maxHealth and newHealth > .5 * maxHealth
!mmm         
!mmm           do m3mgdReleaseAttrCeiling(tokenID, enduranceAttr)
!mmm         
!mmm         end if
!mmm         
!mmm       end if
!mmm       
!mmm       return newHealth
!mmm     
!mmm     else 
!mmm     
!mmm       do whisperback("Error writing changes to health (" & effOffset & ") into " & tokenID & "." & healthAttr)
!mmm       return false
!mmm     
!mmm     end if
!mmm   
!mmm   end if
!mmm   
!mmm end function
!rem 
!rem // m3mgdProcessInjury(tokenID, healthDamageRoll, enduranceDamageRoll, armorApplicable)
!rem // 
!rem //   Executes an injury to tokenID (with or without processing currently worn armor, as per the armorApplicable flag).
!rem //   Sends an update of tokenID's condition to its player.
!rem // 
!mmm function m3mgdProcessInjury(tokenID, healthDamageRoll, enduranceDamageRoll, armorApplicable)
!mmm
!mmm   if enduranceDamageRoll eq ""
!mmm     set enduranceDamage = 0
!mmm   else if enduranceDamageRoll ne "*"
!mmm     set enduranceDamage = roll(enduranceDamageRoll)
!mmm   else if enduranceDamageRoll eq "*" and healthDamageRoll ne "*" and healthDamageRoll ne ""
!mmm     set healthDamage = roll(healthDamageRoll)
!mmm     set enduranceDamage = healthDamage
!mmm   end if
!mmm   if not healthDamage and healthDamageRoll ne ""
!mmm     set healthDamage = 0
!mmm   else if not healthDamage and healthDamageRoll eq "*"
!mmm     set healthDamage = enduranceDamage
!mmm   else if not healthDamage
!mmm     set healthDamage = roll(healthDamageRoll)
!mmm   end if
!mmm   
!rem   // Process endurance loss, if tokenID is not an undead creature with unlimited endurance
!mmm   if not tokenID.(m3mgdGetEnduranceAttribute(tokenID)).max == 0
!mmm     set effEnduranceLoss = highlight(max(0, enduranceDamage), default)
!mmm     set newEndurance = m3mgdModifyEndurance(-effEnduranceLoss, tokenID)
!mmm   end if
!mmm
!rem   // Process health loss, if tokenID is not a ghost (max health > 0)
!mmm   if not tokenID.(m3mgdGetHealthAttribute(tokenID)).max == 0
!mmm     if armorApplicable
!mmm       set effArmorProtection = m3mgdEffectiveArmorProtection(tokenID, attackWeaponType)
!mmm     end if
!mmm     set effHealthLoss = highlight(max(0, healthDamage - effArmorProtection), default, "RS: " & effArmorProtection)
!mmm     set newHealth = m3mgdModifyHealth(-effHealthLoss, tokenID)
!mmm     if effHealthLoss > 0 and newHealth < 0
!mmm       set timeToDie = roll("1d6-" & abs(newHealth)) 
!mmm     end if
!mmm   end if
!mmm 
!mmm   if effHealthLoss > 0 or effEnduranceLoss > 0 
!mmm     combine chat
!mmm       chat: /w "${tokenID.character_name}" ${"&"}{template:default} {\{name=${m3mgdShapeMoji(tokenID) & tokenID.name}: Schaden}\} 
!mmm       chat: {\{ Schaden = ${effHealthLoss} LP / ${effEnduranceLoss} AP }\}
!mmm       if newHealth < 0 and timeToDie < 0
!mmm         chat: {\{Zustand=**Sofortiger Tod &#10013;**}\}
!mmm       else
!mmm         chat: {\{${m3mgdHealthStatusLabel(tokenID)}=${m3mgdHealthStatusEffectsDesc(tokenID)} }\}
!mmm         chat: {\{${m3mgdEnduranceStatusLabel(tokenID)}=${m3mgdEnduranceStatusEffectsDesc(tokenID)} }\}
!mmm       end if
!mmm     end combine
!mmm   end if
!mmm
!mmm   return true
!mmm
!mmm end function
!rem
!rem // m3mgdGetTokenDirection(fromTokenID, toTokenID)
!rem //
!rem // Returns toTokenID's direction from the vantage point of fromTokenID, in degrees. 
!rem //
!mmm function m3mgdGetTokenDirection(fromTokenID, toTokenID)
!mmm
!mmm   set offsetYfromFoe = round((fromTokenID.top  - toTokenID.top)  * distscale())
!mmm   set offsetXfromFoe = round((fromTokenID.left - toTokenID.left) * distscale())
!mmm   return round(atan(-offsetYfromFoe, -offsetXfromFoe)) - 90
!mmm
!mmm end function
!rem
!rem // m3mgdGetViewAngle(fromTokenID, toTokenID)
!rem //
!rem // Returns fromTokenID's angle of vision towards toTokenID, in degrees. 
!rem //
!mmm function m3mgdGetViewAngle(fromTokenID, toTokenID)
!mmm
!mmm   set foeDirectionFromMe = m3mgdGetTokenDirection(fromTokenID, toTokenID)
!mmm   set myViewAngle = ((foeDirectionFromMe - round(fromTokenID.rotation) % 360) + 180) % 360 - 180
!mmm
!mmm   return myViewAngle
!mmm
!mmm end function
!rem
!rem // m3mgdGetDistance(fromTokenID, toTokenID)
!rem //
!rem // Returns distance between fromTokenID and toTokenID, in distunits(). 
!rem //
!mmm function m3mgdGetDistance(fromTokenID, toTokenID)
!mmm
!mmm   set absDistY = ((abs(fromTokenID.top  - toTokenID.top))  - .5 * fromTokenID.height - .5 * toTokenID.height) * distscale()
!mmm   set absDistX = ((abs(fromTokenID.left - toTokenID.left)) - .5 * fromTokenID.width  - .5 * toTokenID.width)  * distscale()
!mmm
!mmm   return round(max(absDistY, absDistX))
!mmm
!mmm end function
!rem
!rem // m3mgdMoveToken(tokenID, offsetRight, offsetForward)
!rem //
!rem //   Moves tokenID by offsetRight grid cells to its right (per its direction of view) and offsetForward cells forward.
!rem //
!mmm function m3mgdMoveToken(tokenID, offsetRight, offsetForward)
!mmm   set bearing = (tokenID.rotation % 360 + atan(offsetRight, offsetForward)) % 360
!mmm   do setattr(tokenID, "left", tokenID.left - sin(bearing) * max(abs(offsetRight), abs(offsetForward)) / distscale())
!mmm   do setattr(tokenID, "top", tokenID.top + cos(bearing) * max(abs(offsetRight), abs(offsetForward)) / distscale())
!mmm end function
!rem
!rem // m3mgdSpawnWeaponToken(originID, offsetRight, offsetForward)
!rem //
!rem //   Uses the SpawnDefaultToken API script (if installed) to make a new weapon token appear at position offsetRight/offsetForward grid cells from originID's direction of view
!rem //
!mmm function m3mgdSpawnWeaponToken(originID, offsetRight, offsetForward)
!mmm   set bearing = (originID.rotation % 360 + round(atan(offsetRight, offsetForward))) % 360
!mmm   set offsetX = -sin(bearing) * max(abs(offsetRight), abs(offsetForward))
!mmm   set offsetY = cos(bearing) * max(abs(offsetRight), abs(offsetForward))
!mmm   chat: !Spawn --name|tokenMuleWeapons --side|rand --offset|${round(offsetX)},${round(offsetY)} --order|top --controlledby|all --tokenProps|name:${originID.name}'s Weapon,showname:1
!mmm end function
!rem
!rem // m3mgdExchangeStoreAttack(attackType, [magicSpell])
!rem //
!mmm function m3mgdExchangeStoreAttack(attackType, magicSpell)
!mmm   
!mmm   set dataExchangeID = m3mgdExchange
!mmm   do m3mgdFlushExchange(dataExchangeID)
!mmm
!mmm   if attackType eq "magic" and isdefault(magicSpell)
!mmm     do whisperback("Incomplete data for a magic attack: spell argument missing")
!mmm     return false
!mmm   else if attackType ne "magic"
!mmm     set magicSpell = ""
!mmm   end if
!mmm 
!mmm   set storeTarget = 4
!mmm   set storeCounter = 0
!mmm
!rem   // Store the bare minimum of any attack dataset
!mmm
!mmm   if setattr(dataExchangeID, m3mgdAttrAttackType, attackType) eq attackType
!mmm     set storeCounter = storeCounter + 1
!mmm   end if
!mmm   if setattrmax(dataExchangeID, m3mgdAttrAttackType, magicSpell) eq magicSpell
!mmm     set storeCounter = storeCounter + 1
!mmm   end if
!mmm   if setattr(dataExchangeID, m3mgdAttrAttackerID, script.cOwnID) eq script.cOwnID
!mmm     set storeCounter = storeCounter + 1
!mmm   end if
!mmm   if setattr(dataExchangeID, m3mgdAttrAttackTargetID, script.cTargetID) eq script.cTargetID
!mmm     set storeCounter = storeCounter + 1
!mmm   end if
!mmm   
!rem   // Store additional data only if present
!mmm
!mmm   if script.attackResult >= 20
!mmm     set storeTarget = storeTarget + 1
!mmm     if setattr(dataExchangeID, m3mgdAttrAttackResult, script.attackResult) == script.attackResult
!mmm       set storeCounter = storeCounter + 1
!mmm     end if
!mmm   end if
!mmm   
!mmm   if script.criticalAttack == true or script.criticalAttack == false
!mmm     set storeTarget = storeTarget + 1
!rem     // normalize boolean variable to avoid setting the attribute to undef (which would evaluate as false above)
!mmm     set criticalAttack = (script.criticalAttack == true)
!mmm     if setattrmax(dataExchangeID, m3mgdAttrAttackResult, criticalAttack) == script.criticalAttack
!mmm       set storeCounter = storeCounter + 1
!mmm     end if
!mmm   end if
!mmm   
!mmm   if script.damageResult ne undef
!mmm     set storeTarget = storeTarget + 1
!mmm     if setattr(dataExchangeID, m3mgdAttrAttackDamage, script.damageResult) == script.damageResult
!mmm       set storeCounter = storeCounter + 1
!mmm     end if
!mmm   end if
!mmm   
!mmm   if script.cDamageRoll ne undef
!mmm     set storeTarget = storeTarget + 1
!mmm     set damageRoll = script.cDamageRoll
!mmm     if damageRoll < 0
!mmm       set damageRoll = 0
!mmm     end if
!mmm     if setattr(dataExchangeID, m3mgdAttrAttackDamageRoll, damageRoll) == damageRoll
!mmm       set storeCounter = storeCounter + 1
!mmm     end if
!mmm   end if
!mmm
!mmm   if script.cWeaponType ne ""
!mmm     set storeTarget = storeTarget + 1
!mmm     if setattr(dataExchangeID, m3mgdAttrAttackWeaponType, script.cWeaponType[0]) eq script.cWeaponType[0]
!mmm       set storeCounter = storeCounter + 1
!mmm     end if
!mmm     if script.cWeaponType[1] ne ""
!mmm       set storeTarget = storeTarget + 1
!mmm       if setattrmax(dataExchangeID, m3mgdAttrAttackWeaponType, script.cWeaponType[1]) eq script.cWeaponType[1]
!mmm         set storeCounter = storeCounter + 1
!mmm       end if
!mmm     end if
!mmm   end if
!mmm
!mmm   return (storeCounter == storeTarget)
!mmm   
!mmm end function
!rem
!rem // m3mgdExchangeStoreHealthBoost(healthGain, targetID)
!rem //
!rem //   Allows for positive AND negative values of healthGain, since critical failures of First Aid etc. result in damage.
!rem //
!mmm function m3mgdExchangeStoreHealthBoost(healthGain, targetID)
!mmm   
!mmm   set dataExchangeID = m3mgdExchange
!mmm
!mmm   if isdefault(healthGain) or not healthGain
!mmm     return false
!mmm   end if
!mmm
!mmm   if isdefault(targetID) and not isunknown(script.cOwnID)
!mmm     return false
!mmm   end if
!mmm 
!mmm   set storeCounter = 0
!mmm   if setattr(dataExchangeID, m3mgdAttrHealthGain, healthGain) eq healthGain
!mmm     set storeCounter = storeCounter + 1
!mmm   end if
!mmm   if setattrmax(dataExchangeID, m3mgdAttrHealthGain, targetID) eq targetID
!mmm     set storeCounter = storeCounter + 1
!mmm   end if
!mmm   return (storeCounter == 2)
!mmm   
!mmm end function
!rem
!rem // m3mgdExchangeStoreEnduranceBoost(enduranceGain, targetID)
!rem //
!rem //   Allows for positive AND negative values of enduranceGain, since critical failures of First Aid etc. result in damage.
!rem //
!mmm function m3mgdExchangeStoreEnduranceBoost(enduranceGain, targetID)
!mmm   
!mmm   set dataExchangeID = m3mgdExchange
!mmm
!mmm   if isdefault(enduranceGain) or not enduranceGain
!mmm     return false
!mmm   end if
!mmm
!mmm   if isdefault(targetID) and not isunknown(script.cOwnID)
!mmm     return false
!mmm   end if
!mmm 
!mmm   set storeCounter = 0
!mmm   if setattr(dataExchangeID, m3mgdAttrEnduranceGain, enduranceGain) eq enduranceGain
!mmm     set storeCounter = storeCounter + 1
!mmm   end if
!mmm   if setattrmax(dataExchangeID, m3mgdAttrEnduranceGain, targetID) eq targetID
!mmm     set storeCounter = storeCounter + 1
!mmm   end if
!mmm   return (storeCounter == 2)
!mmm   
!mmm end function
!rem
!rem // m3mgdListDefenseWeapons(tokenID)
!rem // 
!rem //   Returns a list of tokenID's defense weapons (attribute names), or false if there are none or none accessible.
!rem // 
!mmm function m3mgdListDefenseWeapons(tokenID)
!mmm   for weaponsAttr in findattr(tokenID, "Abwehr", "AbwWaffe")
!mmm     set defenseWeaponsList = defenseWeaponsList, weaponsAttr
!mmm   end for
!mmm   if isunknown(defenseWeaponsList) or isdenied(defenseWeaponsList)
!mmm     return false
!mmm   else 
!mmm     return defenseWeaponsList
!mmm   end if
!mmm end function
!rem
!rem // m3mgdListMeleeAttackWeapons(tokenID)
!rem // 
!rem //   Returns a list of tokenID's melee attack weapons (attribute names), or false if there are none or none accessible.
!rem // 
!mmm function m3mgdListMeleeAttackWeapons(tokenID)
!mmm   set attackWeaponsList = findattr(tokenID, "Angriff", "Waffe")
!mmm   if isunknown(attackWeaponsList) or isdenied(attackWeaponsList)
!mmm     return false
!mmm   end if
!mmm   for attackWeaponAttr in attackWeaponsList
!mmm     if tokenID.(findattr(tokenID, "Angriff", "Waffe", tokenID.(attackWeaponAttr), "FKWaffe")) != 1
!mmm       set meleeAttackWeaponsList = meleeAttackWeaponsList, attackWeaponAttr
!mmm     end if
!mmm   end for
!mmm   return meleeAttackWeaponsList
!mmm end function
!rem
!rem // m3mgdListRangedAttackWeapons(tokenID)
!rem // 
!rem //   Returns a list of tokenID's ranged attack weapons (attribute names), or false if there are none or none accessible.
!rem // 
!mmm function m3mgdListRangedAttackWeapons(tokenID)
!mmm   set attackWeaponsList = findattr(tokenID, "Angriff", "Waffe")
!mmm   if isunknown(attackWeaponsList) or isdenied(attackWeaponsList)
!mmm     return false
!mmm   end if
!mmm   for attackWeaponAttr in attackWeaponsList
!mmm     if tokenID.(findattr(tokenID, "Angriff", "Waffe", tokenID.(attackWeaponAttr), "FKWaffe")) == 1
!mmm       set rangedAttackWeaponsList = rangedAttackWeaponsList, attackWeaponAttr
!mmm     end if
!mmm   end for
!mmm   return rangedAttackWeaponsList
!mmm end function
!rem
!rem // m3mgdDefenseWeaponType(weaponLabel)
!rem // 
!rem //   If weaponLabel is exactly one of a list of standard attack or defense arms, returns the correct weaponType for it. 
!rem //   Otherwise returns unknown. 
!rem // 
!mmm function m3mgdDefenseWeaponType(weaponLabel)
!mmm 
!mmm   set weaponType = unknown
!mmm   
!mmm   if ("Buckler", "großer Schild", "Großer Schild", "kleiner Schild", "Kleiner Schild") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Schild"
!mmm   
!mmm   else if ("Kampfgabeln", "Parierdolch") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Parierwaffe"
!mmm   
!mmm   else if weaponLabel eq "Abwehr ohne Schild" or weaponLabel eq "ohne Schild"
!mmm   
!mmm     set weaponType = ""
!mmm   
!mmm   end if
!mmm   
!mmm   return weaponType
!mmm 
!mmm end function
!rem
!rem // m3mgdMeleeWeaponType(weaponLabel)
!rem // 
!rem //   If weaponLabel is exactly one of a list of standard attack or defense arms, returns the correct weaponType for it. 
!rem //   Otherwise returns unknown. 
!rem // 
!mmm function m3mgdMeleeWeaponType(weaponLabel)
!mmm 
!mmm   set weaponType = unknown
!mmm   
!mmm   if ("Handaxt", "Keule", "Kriegshammer", "Schlachtbeil einhändig", "Steinhammer", "Streitaxt", "Streitkolben") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Einhandschlagwaffe"
!mmm   
!mmm   else if ("Anderthalbhänder", "Krummschwert", "Langschwert", "Krummsäbel", "Säbel") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Einhandschwert"
!mmm   
!mmm   else if ("Florett", "Fuchtel", "Rapier") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Fechtwaffe"
!mmm   
!mmm   else if ("Kriegsflegel", "Morgenstern", "NunChaku") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Kettenwaffe"
!mmm   
!mmm   else if ("Gleffe", "Hellebarde", "leichter Speer", "Stielhammer", "Stoßspeer") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Spießwaffe"
!mmm   
!mmm   else if ("Dolch", "Wurfmesser als Dolch", "Kurzschwert", "Ochsenzunge") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Stichwaffe"
!mmm   
!mmm   else if ("Bo-Stab", "Kampfstab") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Stockwaffe"
!mmm   
!mmm   else if ("Magierstab", "Magierstecken", "Magierstecken gegen Flugwesen") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Zauberstab"
!mmm   
!mmm   else if ("Barbarenstreitaxt", "Gleffe", "Hellebarde", "Ogerhammer", "Schlachtbeil zweihändig", "Stabkeule", "Stielhammer") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Zweihandschlagwaffe"
!mmm   
!mmm   else if ("Anderthalbhänder", "Bihänder") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "Zweihandschwert"
!mmm   
!mmm   else if ("waffenloser Kampf", "Faust", "Faustkampf", "Ringen (ohne Rüstung)", "Ringen (mit Rüstung)", "Tatze", "Klaue", "Tentakel", "Biss", "Horn", "Berührung") where ... eq weaponLabel
!mmm   
!mmm     set weaponType = "waffenlos"
!mmm   
!mmm   end if
!mmm   
!mmm   return weaponType
!mmm 
!mmm end function
!rem
!rem // m3mgdRangedWeaponProperties(weaponLabel)
!rem // 
!rem //   If weaponLabel is exactly one of a list of standard attack or defense arms, returns a list of weaponProperties. 
!rem //   Otherwise returns unknown. 
!rem //   weaponProperties := (weaponType, lowRangeUpperBound, midRangeUpperBound, farRangeUpperBound, ammoLabel)
!rem // 
!mmm function m3mgdRangedWeaponProperties(weaponLabel)
!mmm 
!mmm   set weaponProperties = unknown
!mmm   
!mmm   if weaponLabel eq "Wurfaxt" or weaponLabel eq "Wurfhammer"
!mmm   
!mmm     set weaponProperties = ("Stielwurfwaffe", 10, 20, 30, weaponLabel)
!mmm   
!mmm   else if weaponLabel eq "Wurfeisen" or weaponLabel eq "Wurfkeule"
!mmm   
!mmm     set weaponProperties = ("Stielwurfwaffe", 10, 20, 50, weaponLabel)
!mmm   
!mmm   else if weaponLabel eq "Wurfmesser"
!mmm   
!mmm     set weaponProperties = ("Wurfklinge", 10, 15, 20, weaponLabel)
!mmm   
!mmm   else if weaponLabel eq "Wurfpfeil"
!mmm   
!mmm     set weaponProperties = ("Wurfklinge", 10, 20, 30, weaponLabel)
!mmm   
!mmm   else if weaponLabel eq "Wurfscheibe"
!mmm   
!mmm     set weaponProperties = ("Wurfscheibe", 10, 20, 30, weaponLabel)
!mmm   
!mmm   else if weaponLabel eq "Wurfstern"
!mmm   
!mmm     set weaponProperties = ("Wurfscheibe", 5, 10, 15, weaponLabel)
!mmm   
!mmm   else if weaponLabel eq "Speerschleuder"
!mmm   
!mmm     set weaponProperties = ("Wurfspieß", 20, 40, 70, weaponLabel)
!mmm   
!mmm   else if weaponLabel eq "Wurfspeer"
!mmm   
!mmm     set weaponProperties = ("Wurfspieß", 10, 30, 50, weaponLabel)
!mmm   
!mmm   else if weaponLabel eq "Wurfspieß"
!mmm   
!mmm     set weaponProperties = ("Wurfspieß", 10, 20, 30, weaponLabel)
!mmm   
!mmm   else if weaponLabel eq "leichte Armbrust"
!mmm   
!mmm     set weaponProperties = (weaponLabel, 30, 120, 220, "Bolzen")
!mmm   
!mmm   else if weaponLabel eq "schwere Armbrust"
!mmm   
!mmm     set weaponProperties = (weaponLabel, 30, 120, 240, "Bolzen")
!mmm   
!mmm   else if weaponLabel eq "Handarmbrust"
!mmm   
!mmm     set weaponProperties = (weaponLabel, 20, 40, 70, "Bolzen")
!mmm   
!mmm   else if weaponLabel eq "langes Blasrohr"
!mmm   
!mmm     set weaponProperties = ("Blasrohr", 10, 15, 20, "Pfeile")
!mmm   
!mmm   else if weaponLabel eq "kurzes Blasrohr"
!mmm   
!mmm     set weaponProperties = ("Blasrohr", 5, 7, 10, "Pfeile")
!mmm   
!mmm   else if weaponLabel eq "Bogen"
!mmm   
!mmm     set weaponProperties = (weaponLabel, 30, 100, 180, "Pfeile")
!mmm   
!mmm   else if weaponLabel eq "Kurzbogen"
!mmm   
!mmm     set weaponProperties = (weaponLabel, 30, 80, 120, "Pfeile")
!mmm   
!mmm   else if weaponLabel eq "Kompositbogen"
!mmm   
!mmm     set weaponProperties = (weaponLabel, 30, 120, 200, "Pfeile")
!mmm   
!mmm   else if weaponLabel eq "Langbogen"
!mmm   
!mmm     set weaponProperties = (weaponLabel, 30, 120, 200, "Pfeile")
!mmm   
!mmm   else if weaponLabel eq "Schleuder"
!mmm   
!mmm     set weaponProperties = ("Schleuder", 30, 60, 90, "Kugeln")
!mmm   
!mmm   else if weaponLabel eq "Stockschleuder"
!mmm   
!mmm     set weaponProperties = ("Schleuder", 50, 100, 180, "Kugeln")
!mmm   
!mmm   end if
!mmm   
!mmm   return weaponProperties
!mmm 
!mmm end function
!rem
!rem // m3mgdDefenseInitPayload(tokenID)  
!rem //
!rem //   Returns MMM code for a defense customize block, formatted as a chat button payload.
!rem //   If tokenID.PC==true, the block is designed for player characters (3D roll), otherwise for NPCs (GM silent mode).
!rem //
!mmm function m3mgdDefenseInitPayload(tokenID)  
!mmm   set payload = "!mmm customize&#13;"
!mmm   set payload = payload & literal("!mmm set cSemiManualModifiers=\"?" & "{Standard-Abwehrmodifikatoren| Normale Abwehr +/-0,0| Konzentrierte Abwehr +4,+4| Ich greife überstürzt an -2,-2| Ich bin überrascht -4,-4}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm set cManualModifiers=\"?" & "{Weitere spezielle Abwehrmodifikatoren|0}") & "&#13;"
!mmm   if tokenID.PC
!mmm     set payload = payload & "&amp;{template} &#91;[1d20]] &#123;{&#125;}&#13;"
!mmm     set payload = payload & literal("!mmm set cDefenseRoll=$[" & "[0]]") & "&#13;"
!mmm     set payload = payload & literal("!mmm set cNoDefense=false") & "&#13;"
!mmm   else
!mmm     set payload = payload & literal("!mmm if selected") & "&#13;"
!mmm     set payload = payload & literal("!mmm   set cOwnID = selected.token_id") & "&#13;"
!mmm     set payload = payload & literal("!mmm end if") & "&#13;"
!mmm     set payload = payload & literal("!mmm set cGMSilentMode = true") & "&#13;"
!mmm   end if
!mmm   set payload = payload & "!mmm end customize&#13;"
!mmm   return payload
!mmm end function
!rem
!rem // m3mgdDefenseDataEntryPayload(tokenID)  
!rem //
!rem //   Returns code for a chat button payload to allow user entry of attack data to the defense script.
!rem //   Once data entry is complete, the defense script is also being executed again.
!rem //
!mmm function m3mgdDefenseDataEntryPayload(tokenID)
!mmm   if (isdefault(tokenID) or not m3mgdValidateOwnTokenID(tokenID)) and m3mgdValidateOwnTokenID(script.cOwnID)
!mmm     set tokenID = script.cOwnID
!mmm   else if isdefault(tokenID)
!mmm     do whisperback("m3mgdDefenseDataEntryPayload() called without a valid token ID, defaulting to script.cOwnID failed.")
!mmm     return false
!mmm   end if
!mmm   set payload = "!mmm script&#13;"
!mmm   set payload = payload & literal("!mmm set attackType = \"?" & "{Art des Angriffs|Nahkampf,melee|Fernkampf,ranged}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm set attackerID = \"@" & "{target|Wer greift an?|token_id}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm set targetID = \"@" & "{target|Wer wird angegriffen (Ziel)?|token_id}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm set attackResult = \"?" & "{Angriffswert|0}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm set criticalAttack = \"?" & "{Kritischer Erfolg beim Angriff|Nein,0|Ja,1}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm set attackDamage = \"?" & "{Schaden laut Angreifer|0}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm set attackDamageRoll = \"?" & "{Schadenswurf (Ergebnis von 1W6+1 ohne Boni) laut Angreifer|0}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm set armorPiercing = \"?" & "{Angriff mit Lang-/Kompositbogen oder schwerer Armbrust|Nein,0|Ja,1}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm set weaponType = \"?" & "{Waffentyp|" & stringify(m3mgdValidAttackWeaponTypes, "", "|") & "}\"") & "&#13;"
!mmm   set payload = payload & literal("!mmm if attackResult < 20") & "&#13;"
!mmm   set payload = payload & literal("!mmm   do whisperback(\"Abbruch: Angriff mit **\" & attackResult & \"** war nicht erfolgreich, keine Abwehr nötig.\")") & "&#13;"
!mmm   set payload = payload & literal("!mmm   exit script") & "&#13;"
!mmm   set payload = payload & literal("!mmm end if") & "&#13;"
!mmm   set payload = payload & literal("!mmm do m3mgdFlushExchange()") & "&#13;"
!mmm   set payload = payload & literal("!mmm do setattr(m3mgdExchange, m3mgdAttrAttackType, attackType)") & "&#13;"
!mmm   set payload = payload & literal("!mmm do setattr(m3mgdExchange, m3mgdAttrAttackerID, attackerID)") & "&#13;"
!mmm   set payload = payload & literal("!mmm do setattr(m3mgdExchange, m3mgdAttrAttackTargetID, targetID)") & "&#13;"
!mmm   set payload = payload & literal("!mmm do setattr(m3mgdExchange, m3mgdAttrAttackResult, attackResult)") & "&#13;"
!mmm   set payload = payload & literal("!mmm do setattrmax(m3mgdExchange, m3mgdAttrAttackResult, (criticalAttack == 1))") & "&#13;"
!mmm   set payload = payload & literal("!mmm do setattr(m3mgdExchange, m3mgdAttrAttackDamage, attackDamage)") & "&#13;"
!mmm   set payload = payload & literal("!mmm do setattr(m3mgdExchange, m3mgdAttrAttackDamageRoll, attackDamageRoll)") & "&#13;"
!mmm   set payload = payload & literal("!mmm do setattr(m3mgdExchange, m3mgdAttrAttackArmorPiercing, armorPiercing)") & "&#13;"
!mmm   set payload = payload & literal("!mmm do setattr(m3mgdExchange, m3mgdAttrAttackWeaponType, weaponType)") & "&#13;"
!mmm   set payload = payload & "!mmm end script&#13;"
!mmm   set payload = payload & m3mgdDefenseInitPayload(tokenID)
!mmm   set payload = payload & m3mgdScriptCommands.defense
!mmm   return payload
!mmm end function
!rem
!rem // _m3mgdWeaponButtonPayload(tokenID, weaponsGroup, weaponLabel, [rollData], [rollConfig])
!rem //
!rem //   Returns payload code for a chat button for tokenID to use weaponLabel (offensive or defensive), (re)using rollData/rollConfig about previous die rolls.
!rem //
!mmm function _m3mgdWeaponButtonPayload(tokenID, weaponsGroup, weaponLabel, rollData, rollConfig)
!mmm
!mmm   set weaponScriptCommand = m3mgdScriptCommands.(weaponsGroup)
!rem   // Overwrite weaponScriptCommand if there is a custom config script registered for weaponLabel in tokenID's character sheet
!mmm   set customCall = tokenID.("m3mgd_configCall_" & weaponLabel)
!mmm   if not isunknown(customCall)
!mmm     set weaponScriptCommand = "&#x25;{" & tokenID.character_name & "|" & customCall & "}"
!mmm   end if
!mmm   if weaponsGroup eq "defense"
!mmm     set weaponScriptCommand = m3mgdDefenseInitPayload(tokenID) & weaponScriptCommand
!mmm   end if
!mmm
!mmm   set payload = "!mmm customize&#13;"
!mmm   set payload = payload & literal("!mmm set cOwnID=\"" & tokenID & "\"") & "&#13;"
!mmm
!mmm   if weaponsGroup eq "melee" or weaponsGroup eq "ranged"
!mmm     
!mmm     if not isdefault(rollConfig) and rollConfig.cTargetID ne ""
!mmm       set payload = payload & literal("!mmm set cTargetID=\"" & rollConfig.cTargetID & "\"") & "&#13;"
!mmm     else 
!mmm       set payload = payload & literal("!mmm set cTargetID=\"@" & "{target|Angriffsziel|token_id}\"") & "&#13;"
!mmm     end if
!mmm     
!mmm     set payload = payload & literal("!mmm set cWeaponLabel=\"@" & "{" & tokenID.character_name & "|" & findattr(tokenID, "Angriff", "Waffe", weaponLabel) & "}\"") & "&#13;"
!mmm
!mmm     if weaponsGroup eq "melee"
!mmm
!mmm       set payload = payload & literal("!mmm set cWeaponType=\"" & m3mgdMeleeWeaponType(weaponLabel) & "\"") & "&#13;"
!mmm
!mmm       if not isdefault(rollConfig) and rollConfig.cSemiManualModifiers
!mmm         set payload = payload & literal("!mmm set cSemiManualModifiers=" & rollConfig.cSemiManualModifiers) & "&#13;"
!mmm       else
!mmm         set payload = payload & literal("!mmm set cSemiManualModifiers=") & "?"&"{Standard-Angriffsmodifikatoren|Keine +/-0,?"&"{Keine +/-0 +/-...&amp;vert;Echt keine +/-0&amp;comma;1&amp;vert;Von oben 70cm+ +2&amp;comma;2&amp;vert;Ziel liegt/ich stehe +4&amp;comma;3&amp;vert;Ziel wehrlos/überrascht +4&amp;comma;5&amp;vert;Ziel flieht panisch +4&amp;comma;7&amp;rbrace;|Spontan -4,?"&"{Spontan -4 +/-...&amp;vert;Nix weiter +/-0&amp;comma;11&amp;vert;Von oben 70cm+ +2&amp;comma;22&amp;vert;Ziel liegt/ich stehe +4&amp;comma;33&amp;vert;Ziel wehrlos/überrascht +4&amp;comma;55&amp;vert;Ziel flieht panisch +4&amp;comma;77&amp;rbrace;|Überstürzt -6,?"&"{Überstürzt -6 +/-...&amp;vert;Nix weiter +/-0&amp;comma;13&amp;vert;Von oben 70cm+ +2&amp;comma;26&amp;vert;Ziel liegt/ich stehe +4&amp;comma;39&amp;vert;Ziel wehrlos/überrascht +4&amp;comma;65&amp;vert;Ziel flieht panisch +4&amp;comma;91&amp;rbrace;|Völlig dunkel/geblendet -6,?"&"{Völlig dunkel/geblendet -6 +/-...&amp;vert;Nix weiter +/-0&amp;comma;17&amp;vert;Von oben 70cm+ +2&amp;comma;34&amp;vert;Ziel liegt/ich stehe +4&amp;comma;51&amp;vert;Ziel wehrlos/überrascht +4&amp;comma;85&amp;vert;Ziel flieht panisch +4&amp;comma;119&amp;vert;Spontan -4&amp;comma;?"&"{Keine +/-0 +/-...&amp;amp;vert;Echt keine +/-0&amp;amp;comma;187&amp;amp;vert;Von oben 70cm+ +2&amp;amp;comma;374&amp;amp;vert;Ziel liegt/ich stehe +4&amp;amp;comma;561&amp;amp;vert;Ziel wehrlos/überrascht +4&amp;amp;comma;935&amp;amp;vert;Ziel flieht panisch +4&amp;amp;comma;1309&amp;amp;rbrace;&amp;vert;Überstürzt -6&amp;comma;?"&"{Keine +/-0 +/-...&amp;amp;vert;Echt keine +/-0&amp;amp;comma;221&amp;amp;vert;Von oben 70cm+ +2&amp;amp;comma;442&amp;amp;vert;Ziel liegt/ich stehe +4&amp;amp;comma;663&amp;amp;vert;Ziel wehrlos/überrascht +4&amp;amp;comma;1105&amp;amp;vert;Ziel flieht panisch +4&amp;amp;comma;1547&amp;amp;rbrace;&amp;rbrace; }&#13;"
!mmm       end if
!mmm
!mmm     else if weaponsGroup eq "ranged"
!mmm
!mmm       set payload = payload & literal("!mmm set cWeaponType=\"" & m3mgdRangedWeaponProperties(weaponLabel)[0] & "\"") & "&#13;"
!mmm
!mmm       if not isdefault(rollConfig) and rollConfig.cSemiManualModifiers
!mmm         set payload = payload & literal("!mmm set cSemiManualModifiers=" & rollConfig.cSemiManualModifiers) & "&#13;"
!mmm       else
!mmm         set payload = payload & literal("!mmm set cSemiManualModifiers=") & "?"&"{Standard-Angriffsmodifikatoren|Keine +/-0,?"&"{Keine +/-0 +/-...&amp;vert;Echt keine +/-0&amp;comma;1&amp;vert;Mini-Ziel 1/4xMensch -4&amp;comma;2&amp;vert;Kleines Ziel 1/2xMensch -2&amp;comma;3&amp;vert;Großes Ziel 2xMensch +2&amp;comma;5&amp;vert;Riesiges Ziel 4xMensch +4&amp;comma;7&amp;vert;Ins Handgemenge/Zufallsopfer +4&amp;comma;17&amp;rbrace;|Spontan -4,?"&"{Spontan -4 +/-...&amp;vert;Nix weiter +/-0&amp;comma;11&amp;vert;Mini-Ziel 1/4xMensch -4&amp;comma;22&amp;vert;Kleines Ziel 1/2xMensch -2&amp;comma;33&amp;vert;Großes Ziel 2xMensch +2&amp;comma;55&amp;vert;Riesiges Ziel 4xMensch +4&amp;comma;77&amp;vert;Schnelles Ziel/B30+ -2&amp;comma;143&amp;vert;Ins Handgemenge/Zufallsopfer +4&amp;comma;187&amp;rbrace;|Schnelles Ziel/B30+ -2,?"&"{Schnelles Ziel/B30+ -2 +/-...&amp;vert;Nix weiter +/-0&amp;comma;13&amp;vert;Mini-Ziel 1/4xMensch -4&amp;comma;26&amp;vert;Kleines Ziel 1/2xMensch -2&amp;comma;39&amp;vert;Großes Ziel 2xMensch +2&amp;comma;65&amp;vert;Riesiges Ziel 4xMensch +4&amp;comma;91&amp;vert;Spontan -4&amp;comma;143&amp;vert;10 Sekunden gezielt +4&amp;comma;247&amp;rbrace;|10 Sekunden gezielt +4,?"&"{10 Sekunden gezielt +4 +/-...&amp;vert;Nix weiter +/-0&amp;comma;19&amp;vert;Mini-Ziel 1/4xMensch -4&amp;comma;38&amp;vert;Kleines Ziel 1/2xMensch -2&amp;comma;57&amp;vert;Großes Ziel 2xMensch +2&amp;comma;95&amp;vert;Riesiges Ziel 4xMensch +4&amp;comma;133&amp;vert;Schnelles Ziel/B30+ -2&amp;comma;247&amp;rbrace;|Scharfschießen +4/Spezial,?"&"{Scharfschießen +4/Spezial&amp;vert;Nix weiter +/-0&amp;comma;23&amp;vert;Mini-Ziel 1/4xMensch -4&amp;comma;46&amp;vert;Kleines Ziel 1/2xMensch -2&amp;comma;69&amp;vert;Großes Ziel 2xMensch +2&amp;comma;115&amp;vert;Riesiges Ziel 4xMensch +4&amp;comma;161&amp;vert;Schnelles Ziel/B30+ -2&amp;comma;299&amp;rbrace; }&#13;"
!mmm       end if
!mmm
!mmm     end if
!mmm
!mmm     if not isdefault(rollConfig) and rollConfig.cManualModifiers ne undef
!mmm       set payload = payload & literal("!mmm set cManualModifiers=" & rollConfig.cManualModifiers) & "&#13;"
!mmm     else
!mmm       set payload = payload & literal("!mmm set cManualModifiers=?" & "{Weitere spezielle Angriffsmodifikatoren|0}") & "&#13;"
!mmm     end if
!mmm
!mmm     if tokenID.PC
!mmm       set payload = payload & literal("!mmm set cGMSilentMode=false") & "&#13;"
!mmm     else
!mmm       set payload = payload & literal("!mmm set cGMSilentMode=true") & "&#13;"
!mmm     end if
!mmm       
!mmm   else if weaponsGroup eq "defense"
!mmm       
!mmm     set payload = payload & literal("!mmm set cWeaponLabel=\"@" & "{" & tokenID.character_name & "|" & findattr(tokenID, "Abwehr", "AbwWaffe", weaponLabel) & "}\"") & "&#13;"
!mmm     set payload = payload & literal("!mmm set cWeaponType=\"" & m3mgdDefenseWeaponType(weaponLabel) & "\"") & "&#13;"
!mmm       
!mmm   end if
!mmm
!rem   // Make or pass on any rolls
!mmm   if not isdefault(rollData)
!mmm     for singleRoll in rollData...
!rem       // For simple numbers, just hand them over
!mmm       if singleRoll.value + 0 eq singleRoll.value
!mmm         set payload = payload & literal("!mmm set " & singleRoll.key & "=roll(" & singleRoll.value & ")") & "&#13;"
!mmm       else if singleRoll.value eq "1d20cs" or singleRoll.value eq "1d20cf"
!mmm         set payload = payload & literal("!mmm for r in roll('1d20')")
!mmm         for i in 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
!mmm           set payload = payload & literal(",roll('1d20')")
!mmm         end for
!mmm         set payload = payload & "&#13;"
!mmm         if singleRoll.value eq "1d20cs"
!mmm           set payload = payload & literal("!mmm exit for if iscritical(r)") & "&#13;"
!mmm         else if singleRoll.value eq "1d20cf"
!mmm           set payload = payload & literal("!mmm exit for if isfumble(r)") & "&#13;"
!mmm         end if
!mmm         set payload = payload & "!mmm end for&#13;"
!mmm         set payload = payload & literal("!mmm set " & singleRoll.key & "=r") & "&#13;"
!rem       // Non-numbers should be dice syntax ("1d20"): roll them for player characters, otherwise the default will kick in
!mmm       else if tokenID.PC and singleRoll.value
!mmm         set payload = payload & "&amp;{template} &#91;[" & singleRoll.value & "]] &#123;{&#125;}&#13;"
!mmm         set payload = payload & literal("!mmm set " & singleRoll.key & "=$[" & "[0]]") & "&#13;"
!mmm       end if
!mmm     end for
!mmm   end if 
!mmm
!mmm   set payload = payload & "!mmm end customize&#13;"
!mmm   set payload = payload & weaponScriptCommand
!mmm
!mmm   return payload
!mmm
!mmm end function
!rem
!rem // m3mgdWeaponSelectorChatMenu([tokenID], [weaponsGroup], [attackWeaponType])  
!rem //
!rem //   Returns code for a chat menu for tokenID to select among weaponsGroup ("defense", "melee" or "ranged").
!rem //   Buttons execute a customize block to hand over the chosen weapon to the relevant script. 
!rem //   Scripts called differ between player characters (identified by the attribute "PC" evaluating as true) and NPCs.
!rem //
!mmm function m3mgdWeaponSelectorChatMenu(tokenID, weaponsGroup, attackWeaponType)  
!mmm   
!mmm   if isdefault(tokenID)
!mmm     set tokenID = sender.token_id
!mmm   end if
!mmm   
!mmm   if isdefault(weaponsGroup)
!mmm     set weaponsGroup = "melee"
!mmm   end if
!mmm
!mmm   if weaponsGroup eq "defense" and (isdefault(attackWeaponType) or isunknown(attackWeaponType))
!mmm     do whisperback("m3mgdWeaponSelectorChatMenu(): called for defense weapons without attackWeaponType. Aborting.")
!mmm     return false
!mmm   end if
!mmm   
!mmm   if weaponsGroup eq "defense"
!rem     // Will show "no-defense" option in any case; add defense options only if we don't already know that the token is a defenseless target
!mmm     if not m3mgdIsDefenseless(tokenID)
!mmm       set weaponsList = m3mgdListDefenseWeapons(tokenID)
!mmm     end if
!mmm     set selectorPrompt = "Auswahl: Abwehrwaffe"
!mmm   else if weaponsGroup eq "melee"
!mmm     set weaponsList = m3mgdListMeleeAttackWeapons(tokenID)
!mmm     set selectorPrompt = "Auswahl: Nahkampfwaffe"
!mmm   else if weaponsGroup eq "ranged"
!mmm     set weaponsList = m3mgdListRangedAttackWeapons(tokenID)
!mmm     set selectorPrompt = "Auswahl: Fernkampfwaffe"
!mmm   end if
!mmm   
!mmm   if isunknown(tokenID.PC)
!mmm     set selectorPrompt = selectorPrompt & " (🤐) "
!mmm   end if
!mmm
!mmm   if weaponsGroup eq "defense"
!mmm     set noDefensePayload = "!mmm customize&#13;"
!mmm     set noDefensePayload = noDefensePayload & "!mmm set cOwnID&#x3D;&#x22;" & tokenID & "&#x22;&#13;"
!mmm     set noDefensePayload = noDefensePayload & "!mmm set cNoDefense&#x3D;&#x22;true&#x22;&#13;"
!mmm     set noDefensePayload = noDefensePayload & "!mmm end customize&#13;"
!mmm     set noDefensePayload = noDefensePayload & m3mgdScriptCommands.defense
!mmm     set selectorPrompt = selectorPrompt & " [Wehrlos](" & noDefensePayload & cssTableHeaderButton & ") "
!mmm   end if
!mmm
!mmm   set chatMenu = ""
!mmm   set itemCounter = 0
!mmm
!mmm   for weaponLabelAttr in weaponsList
!mmm     
!mmm     set weaponLabel = tokenID.(weaponLabelAttr)
!mmm     
!mmm     if weaponsGroup eq "defense"
!mmm       
!rem       // Check if weaponLabel may not help against attackWeaponType 
!mmm       if weaponLabel eq "Abwehr ohne Schild" or weaponLabel eq "ohne Schild"
!mmm         set weaponUsable = true
!mmm       else
!mmm         set weaponUsable = false
!mmm         if m3mgdParryLargeShieldTypes where ... eq weaponLabel 
!mmm           set weaponUsable = true
!mmm         else if (m3mgdParrySmallShieldTypes where ... eq weaponLabel) and (m3mgdParrySmallShieldEffectiveAgainst where ... eq attackWeaponType)
!mmm           set weaponUsable = true
!mmm         else if (m3mgdParryStandardTypes where ... eq weaponLabel) and (m3mgdParryStandardEffectiveAgainst where ... eq attackWeaponType)
!mmm           set weaponUsable = true
!mmm         end if
!mmm       end if
!mmm       set rollSpecs = {}
!mmm       
!mmm     else if weaponsGroup eq "melee" or weaponsGroup eq "ranged"
!mmm     
!mmm       set weaponUsable = true
!mmm       set rollSpecs = { "cAttackRoll": "1d20", "cDamageRoll": tokenID.(findattr(tokenID, "Angriff", "Waffe", weaponLabel, "WaffeSchaden")) }
!mmm     
!mmm     end if
!mmm
!mmm     if weaponUsable
!mmm
!mmm       set payload = _m3mgdWeaponButtonPayload(tokenID, weaponsGroup, weaponLabel, rollSpecs)
!mmm       
!mmm       if itemCounter % 2 == 0
!mmm         set chatMenu = chatMenu & "{\{[" & weaponLabel & "](" & payload & ")="
!mmm       else
!mmm         set chatMenu = chatMenu & "[**" & weaponLabel & "**](" & payload & ")}\}"
!mmm       end if
!mmm       set itemCounter = itemCounter + 1
!mmm
!mmm     end if
!mmm
!mmm   end for
!mmm
!mmm   if itemCounter % 2 != 0
!mmm     set chatMenu = chatMenu & "}\}"
!mmm   else if itemCounter == 0
!mmm     set chatMenu = chatMenu & "{\{(keine)}\}"
!mmm   end if
!mmm   set chatMenu = "&" & "{template:default} {\{name=" & selectorPrompt & "}\} " & chatMenu
!rem
!mmm   return chatMenu
!mmm   
!mmm end function
!rem
!rem // m3mgdGetCriticalEffect(type, selectRoll)
!rem //
!rem //   Retrieves the critical (type) rolled with (selectRoll). Requires m3mgdCriticalEffectsTable to be in order.
!rem //
!mmm function m3mgdGetCriticalEffect(type, selectRoll)
!mmm   for effectRow in m3mgdCriticalEffectsTable.(type)... order (...left.key < ...right.key)
!mmm     if selectRoll <= effectRow.key
!mmm       return effectRow.value
!mmm     end if
!mmm   end for
!mmm end function
!rem
!rem // m3mgdStorePersistentEffect(tokenID, persistentEffect)
!rem //
!rem //   Stores a persistent effect for tokenID. Duration and effects are stored in the persistentEffect struct:
!rem //   persistentEffect = { 
!rem //     label: "string", 
!rem //     desc: "string", 
!rem //     effect: { 
!rem //       expiry: { type: "[round|attack|defense]", count: integer or dice formula ("1d6+3") },   // plus one or more of the following:
!rem //       [rollModifiers: { [attack|meleeAttack|rangedAttack|defense]: integer },]
!rem //       [noAttack|noDefense|noFocusedDefense: true,]
!rem //       [cappedAttribute: "(valid attribute for tokenID)",]
!rem //       [marker: "(valid status marker for tokenID)"]
!rem //     }
!rem //   }
!rem //   Returns the stored persistentEffect struct, updated by whatever dice thrown to resolve effect.expiry.count.
!rem //
!mmm function m3mgdStorePersistentEffect(tokenID, persistentEffect)
!mmm
!mmm   set tokenID = m3mgdValidateOwnTokenID(tokenID)
!mmm   if not tokenID
!mmm     do whisperback("m3mgdStorePersistentEffect() called without a valid tokenID. Exiting function.")
!mmm     return false
!mmm   end if
!mmm   
!rem   // For variable expiry counts, make the roll and update persistentEffect with the result
!mmm   if persistentEffect.effect.expiry.count and (persistentEffect.effect.expiry.count + 0 ne persistentEffect.effect.expiry.count)
!mmm     set persistentEffect = { persistentEffect, effect: { persistentEffect.effect, expiry: { persistentEffect.effect.expiry, count: roll(persistentEffect.effect.expiry.count) } } }
!mmm   end if
!mmm
!rem   // New effects counting rounds need to be marked as new, so they are not immediately counted down at end of the current round
!mmm   if persistentEffect.effect.expiry.type eq "round"
!mmm     set persistentEffect = { persistentEffect, effect: { persistentEffect.effect, expiry: { persistentEffect.effect.expiry, new: true } } }
!mmm   end if
!mmm
!mmm   do setattr(tokenID, "status_blue", tokenID.status_blue + 1)
!mmm
!mmm   set effectsDB = deserialize(m3mgdExchange.m3mgdActivePersistentEffects)
!mmm   set newList = effectsDB.(tokenID), persistentEffect
!mmm   set effectsDB = { effectsDB, (tokenID): newList }
!mmm   do setattr(m3mgdExchange, "m3mgdActivePersistentEffects", serialize(effectsDB))
!mmm
!mmm   return m3mgdGetActivePersistentEffects(tokenID)
!mmm
!mmm end function
!rem
!rem // m3mgdExecuteCriticalEffect(tokenID, tableName, rollResult, [context], [foeID])
!rem //
!rem //   Pulls the criticalEffect struct defined by tableName and rollResult, and executes it for tokenID, context and foeID. 
!rem //   Valid criticalEffect structs:
!rem //   criticalEffect = {
!rem //     weight: integer,
!rem //     url: string,
!rem //     label: "string",
!rem //     desc: ["string" | { "context 1": "string", "context 2": "string", ...}],
!rem //     [userInput]: {}, // key:value pairs defining the two sides of an MMM set statement, e.g. "myVar": "@" & "{Is the sky blue?|Yes,1|No,0}", made available to the code stored as immediate
!rem //     [immediate]: *,  // Could be a string (Roll20 chat command), a list of strings, or a struct that maps context identifiers (keys, as in desc above) to either strings or list of strings holding chat commands (values)
!rem //     [persistent]: {} // struct as documented in m3mgdStorePersistentEffect()
!rem //   }
!rem //
!mmm function m3mgdExecuteCriticalEffect(tokenID, tableName, rollResult, context, foeID)
!mmm   
!mmm   if isdefault(tokenID) or not m3mgdValidateOwnTokenID(tokenID)
!mmm     do whisperback("m3mgdExecuteCriticalEffect() called without a valid token ID.")
!mmm     return false
!mmm   end if
!mmm
!mmm   set criticalEffect = m3mgdGetCriticalEffect(tableName, rollResult)
!mmm   set codeLines = undef
!mmm   set sender = tokenID.token_name
!mmm
!mmm   combine chat
!mmm     if isdefault(context)
!mmm       chat: ${"&"}{template:default} {\{name=${tokenID.token_name} würfelt ${criticalEffect.label} }\}
!mmm     else 
!mmm       chat: ${"&"}{template:default} {\{name=${tokenID.token_name} würfelt ${criticalEffect.label} (${context}) }\}
!mmm     end if
!mmm     chat: {\{Wurf=${highlight(rollResult, "normal", "Wurf mit 1W100")} }\}
!mmm     if criticalEffect.desc + 0 == 0
!mmm       set descText = criticalEffect.desc
!mmm     else 
!mmm       set descText = criticalEffect.desc.(context)
!mmm     end if
!mmm     chat: {\{Folgen=${descText} }\}
!mmm
!mmm     if criticalEffect.immediate.(context)
!mmm       set codeLines = criticalEffect.immediate.(context)
!mmm     else if isdefault(context)
!mmm       set codeLines = criticalEffect.immediate
!mmm     end if
!mmm     
!mmm     if criticalEffect.persistent.expiry
!mmm       set persistentEffectsList = criticalEffect.persistent
!mmm     else if criticalEffect.persistent.(context).expiry or (criticalEffect.persistent.(context)[0].expiry and criticalEffect.persistent.(context)[1].expiry)
!mmm       set persistentEffectsList = criticalEffect.persistent.(context)
!mmm     end if
!mmm     for persistentEffect in persistentEffectsList
!mmm       set persistentEffect = { effect: persistentEffect, label: criticalEffect.label, desc: descText }
!mmm       if persistentEffect.effect.focus eq "foe"
!mmm         set targetID = foeID
!mmm       else if persistentEffect
!mmm         set targetID = tokenID
!mmm       end if
!mmm       set persistentEffect = m3mgdStorePersistentEffect(targetID, persistentEffect)
!mmm       chat: {\{ ${persistentEffect.label}=${persistentEffect.effect} }\}
!mmm     end for
!mmm
!mmm   end combine
!mmm
!mmm   if codeLines
!mmm     set currentEffect = criticalEffect
!mmm     publish to sender: currentEffect
!mmm     do _m3mgdExecuteCode(codeLines, tokenID, foeID)
!mmm   end if
!mmm
!mmm end function
!rem
!rem // m3mgdCriticalEffectRollPayload(tokenID, tableName, rollResult, foeID)
!rem //
!rem //   Chats a prompt to the GM that shows the critical effect selected from tableName by rollResult.
!rem //   GM can approve the roll to be sent to the affected player, or re-roll.
!rem //
!mmm function m3mgdCriticalEffectRollPayload(tokenID, tableName, foeID)
!mmm   set rollPayload = "!mmm script&#13;"
!mmm   if tokenID.PC
!mmm     set rollPayload = rollPayload & "&amp;{template} &#91;[1d100]] &#123;{&#125;}&#13;"
!mmm     set rollPayload = rollPayload & literal("!mmm set critRoll = $[" & "[0]]") & "&#13;"
!mmm   else 
!mmm     set rollPayload = rollPayload & literal("!mmm set critRoll = roll('1d100')") & "&#13;"
!mmm   end if
!mmm   set rollPayload = rollPayload & literal("!mmm do m3mgdCriticalEffectPrompt(\"" & tokenID & "\",\"" & tableName & "\",critRoll,\"" & foeID & "\")") & "&#13;"
!mmm   set rollPayload = rollPayload & "!mmm end script&#13;"
!mmm   return rollPayload
!mmm end function
!rem
!rem // m3mgdCriticalEffectPrompt(tokenID, tableName, rollResult, foeID)
!rem //
!rem //   Chats a prompt to the GM that shows the critical effect selected from tableName by rollResult.
!rem //   GM can approve the roll to be sent to the affected player, or re-roll.
!rem //
!mmm function m3mgdCriticalEffectPrompt(tokenID, tableName, rollResult, foeID)
!mmm
!mmm   if isdefault(tokenID) or not m3mgdValidateOwnTokenID(tokenID)
!mmm     do whisperback("m3mgdCriticalEffectPrompt() called without a valid token ID.")
!mmm     return false
!mmm   end if
!mmm   set criticalEffect = m3mgdGetCriticalEffect(tableName, rollResult)
!mmm
!mmm   set sender = tokenID.token_name
!mmm   set rollResult = highlight(rollResult, default, "1W100: " & tableName)
!mmm
!mmm   combine chat
!mmm
!mmm     chat: /w GM ${"&"}{template:default} {\{name=${tokenID.token_name} würfelt ${criticalEffect.label} }\}
!mmm     if isdefault(foeID)
!mmm       chat: {\{Wurf=${rollResult} }\}
!mmm     else
!mmm       chat: {\{Wurf=${rollResult} &nbsp; **Gegner:** ${highlight(foeID.name,"info")} }\}
!mmm     end if
!mmm 
!mmm     if criticalEffect.desc + 0 == 0
!mmm
!mmm       set approvePayload = "!mmm script&#13;"
!mmm       for var in criticalEffect.userInput...
!mmm         set approvePayload = approvePayload & literal("!mmm set " & var.key & "=" & var.value) & "&#13;"
!mmm         set approvePayload = approvePayload & literal("!mmm publish to sender: " & var.key) & "&#13;"
!mmm       end for
!mmm       set approvePayload = approvePayload & literal("!mmm do m3mgdExecuteCriticalEffect(\"" & tokenID & "\",\"" & tableName & "\"," & rollResult & ",default,\"" & foeID & "\")") & "&#13;"
!mmm       set approvePayload = approvePayload & "!mmm end script&#13;"
!mmm       chat: {\{ Effekte = ${criticalEffect.desc}${"<"&"br>"}[🖅 **an ${tokenID.character_name}**](${approvePayload}) }\}
!mmm
!mmm     else 
!mmm
!mmm       for contextDesc in criticalEffect.desc...
!mmm         set approvePayload = "!mmm script&#13;"
!mmm         for var in criticalEffect.userInput...
!mmm           set approvePayload = approvePayload & literal("!mmm set " & var.key & "=" & var.value) & "&#13;"
!mmm           set approvePayload = approvePayload & literal("!mmm publish to sender: " & var.key) & "&#13;"
!mmm         end for
!mmm         set approvePayload = approvePayload & literal("!mmm do m3mgdExecuteCriticalEffect(\"" & tokenID & "\",\"" & tableName & "\"," & rollResult & ",\"" & contextDesc.key & "\",\"" & foeID & "\")") & "&#13;"
!mmm         set approvePayload = approvePayload & "!mmm end script&#13;"
!mmm         chat: {\{ ${contextDesc.key} = ${contextDesc.value}${"<"&"br>"}[🖅 **an ${tokenID.character_name}**](${approvePayload}) }\}
!mmm       end for
!mmm
!mmm     end if
!mmm
!mmm     chat: {\{  = [🎲 nochmal würfeln](${m3mgdCriticalEffectRollPayload(tokenID, tableName, foeID)}) }\}
!mmm
!mmm   end combine
!mmm   
!mmm end function
!rem
!rem // m3mgdUpdatePersistentEffectsCounters(tokenID, actionType)
!rem // 
!rem //   For tokenID, counts every active persistent effect counter of the type actionType down by one, save if it is marked as "new" (then the "new" marker is removed).
!rem // 
!mmm function m3mgdUpdatePersistentEffectsCounters(tokenID, actionType)
!mmm debug do tokenID, actionType
!mmm   if not m3mgdHasActivePersistentEffects(tokenID)
!mmm     return false
!mmm   end if
!mmm
!mmm   set currentTypeEffects = 0
!mmm   set newEffectsRemoved = 0
!mmm   set effectCountersDecreased = 0
!mmm   set effectsExpired = 0
!mmm   for activeEffect in m3mgdGetActivePersistentEffects(tokenID)
!mmm     if activeEffect.effect.expiry and activeEffect.effect.expiry.type eq actionType
!mmm       set currentTypeEffects = currentTypeEffects + 1
!mmm       if actionType eq "round" and activeEffect.effect.expiry.new 
!mmm         set activeEffect = { activeEffect, effect: { activeEffect.effect, expiry: { activeEffect.effect.expiry... where ...key ne "new" } } }
!mmm         set newEffectsRemoved = newEffectsRemoved + 1
!mmm       else if activeEffect.effect.expiry.count > 1
!mmm         set activeEffect = { activeEffect, effect: { activeEffect.effect, expiry: { activeEffect.effect.expiry, count: activeEffect.effect.expiry.count - 1 } } }
!mmm         set effectCountersDecreased = effectCountersDecreased + 1
!mmm       else
!mmm         if activeEffect.effect.cappedAttribute
!mmm           do setattr(tokenID, activeEffect.effect.cappedAttribute, tokenID.(activeEffect.effect.cappedAttribute).max)
!mmm         end if
!mmm         if activeEffect.effect.marker
!mmm           do setattr(tokenID, activeEffect.effect.marker, false)
!mmm         end if
!mmm         set activeEffect = undef
!mmm         if tokenID.status_blue > 1
!mmm           do setattr(tokenID, "status_blue", tokenID.status_blue - 1)
!mmm         else
!mmm           do setattr(tokenID, "status_blue", false)
!mmm         end if 
!mmm         set effectsExpired = effectsExpired + 1
!mmm       end if
!mmm     end if
!mmm     if activeEffect
!mmm       set updatedActiveEffects = updatedActiveEffects, activeEffect
!mmm     end if
!mmm   end for
!mmm
!mmm   set effectsDB = deserialize(m3mgdExchange.m3mgdActivePersistentEffects)
!mmm   do setattr(m3mgdExchange, "m3mgdActivePersistentEffects", serialize({ effectsDB, (tokenID): updatedActiveEffects }))
!mmm
!mmm   set summaryLog = "Von " & currentTypeEffects & " " & actionType & "-Effekten: " & newEffectsRemoved & " NEU-Marker entfernt, "
!mmm   set summaryLog = summaryLog & effectCountersDecreased & " Zähler reduziert, " & effectsExpired & " Effekte beendet."
!mmm
!mmm   return summaryLog
!mmm
!mmm end function
!rem
!rem // m3mgdEffectiveArmorProtection(tokenID, attackWeaponType)
!rem //
!rem //   Returns tokenID's current effective armor protection against attackWeapontype as a highlight() struct with metadata in the tooltip 
!rem //
!mmm function m3mgdEffectiveArmorProtection(tokenID, attackWeaponType)
!mmm
!mmm   set armorLabel = (tokenID.repeating.ruestung where ...RsGetragen == true).Rüstung
!mmm   set nominalArmorProtection = (tokenID.repeating.ruestung where ...RsGetragen == true).RüsLP
!mmm   if isunknown(nominalArmorProtection)
!rem     // For NPC tokens where the search for "RsGetragen==true" doesn't work, just take first armor in sheet
!mmm     set armorLabel = tokenID.repeating.ruestung.Rüstung
!mmm     set nominalArmorProtection = tokenID.repeating.ruestung.RüsLP
!mmm   end if
!mmm   
!mmm   if isunknown(nominalArmorProtection)
!mmm     return false
!mmm   else if nominalArmorProtection > 3 and ((m3mgdArmorPiercingWeaponTypes where ... eq attackWeaponType) eq attackWeaponType)
!mmm     return highlight(3, "info", armorLabel & ", reduziert wg. Geschosstyp (" & attackWeaponType & ")")
!mmm   else 
!mmm     return highlight(nominalArmorProtection, "info", armorLabel)
!mmm   end if
!mmm 
!mmm end function
!rem
!rem // m3mgdProcessCombatPP(ownID, weaponLabel, [targetID])
!rem //
!rem //   Processes gain of a practice point for ownID's critically successful attack or defense roll using weaponLabel (in case of an attack, to hit targetID).
!rem //
!mmm function m3mgdProcessCombatPP(ownID, weaponLabel, targetID)
!mmm
!mmm   if ownID.permission ne "control"
!mmm     do whisperback("m3mgdProcessCombatPP(): Unable to register practice point for critically successful attack: no control over token '" & ownID.name & "'")
!mmm     return false
!mmm   end if
!mmm   
!mmm   if isdefault(weaponLabel) or not ((isdefault(targetID) and ownID.(findattr(ownID, "Abwehr", "AbwWaffe", weaponLabel, "FWAbwWaffe"))) or (not isdefault(targetID) and ownID.(findattr(ownID, "Angriff", "Waffe", weaponLabel, "WaffeEW"))))
!mmm     do whisperback("m3mgdProcessCombatPP(): Unable to register practice point for critically successful attack: weapon '" & weaponLabel & "' not found for token '" & ownID.name & "'")
!mmm     return false
!mmm   end if
!mmm
!mmm   if isdefault(targetID)
!mmm
!rem     // Defense critical success
!mmm
!mmm     set weaponPPattr = findattr(ownID, "Abwehr", "AbwWaffe", weaponLabel, "AbWWaffePP")
!mmm
!mmm   else
!mmm
!rem     // Attack critical success
!mmm
!mmm     if targetID.permission ne "view" and targetID.permission ne "control"
!mmm       do whisperback("m3mgdProcessCombatPP(): Unable to register practice point for critically successful attack: invalid target token or no view access to token '" & targetID.name & "'")
!mmm       return false
!mmm     end if
!mmm   
!mmm     if m3mgdIsExhausted(targetID)
!mmm       do whisperback("m3mgdProcessCombatPP(): No practice point registered for critically successful attack on an exhausted target ('" & targetID.name & "')")
!mmm       return false
!mmm     end if
!mmm   
!mmm     set weaponPPattr = findattr(ownID, "Angriff", "Waffe", weaponLabel, "WaffePP")
!mmm
!mmm   end if
!mmm
!rem   // Roll20 stores only attributes that have been touched at least once, so if the attribute is missing, it needs to be created first
!mmm   if not weaponPPattr
!mmm     set weaponPPattr = findattr(ownID, "Angriff", "Waffe", weaponLabel, "Waffe") & "PP"
!mmm     if setattr(ownID, weaponPPattr, 0) != 0
!mmm       do whisperback("m3mgdProcessCombatPP(): Failure initializing unused practice points attribute '" & ownID.name & "'." & weaponPPattr)
!mmm       return false
!mmm     end if
!mmm   end if
!mmm   set oldPP = ownID.(weaponPPattr)
!mmm   set newPP = oldPP + 1
!mmm   if setattr(ownID, weaponPPattr, newPP) != newPP
!mmm     do whisperback("m3mgdProcessCombatPP(): Failure storing new practice points total " & newPP & " in attribute '" & ownID.name & "'." & weaponPPattr)
!mmm     return false
!mmm   end if
!mmm
!mmm   set logLine = "PP:" & weaponLabel & "(" & newPP & ")=Kritisch erfolgreicher Angriff auf " & targetID.name & " (AP=" & cTargetID.(m3mgdGetEnduranceAttribute(cTargetID)) & ")"
!mmm   if isunknown(ownID.(m3mgdAttrXPLog))
!mmm     do setattr(ownID, m3mgdAttrXPLog, "")
!mmm   end if
!mmm   do setattr(ownID, m3mgdAttrXPLog, ownID.(m3mgdAttrXPLog) & " {\{" & logLine & "}\} ")
!mmm
!mmm   return true
!mmm
!mmm end function
!rem
!rem // m3mgdProcessAttackXP(attackType, attackDamageRoll, [attackerID], [targetID])
!rem //
!rem //   Processes experience gain from mundane attacks (attackType: melee, ranged or magic).
!rem //
!mmm function m3mgdProcessAttackXP(attackType, attackDamageRoll, attackerID, targetID)
!mmm
!mmm   if isdefault(attackType) or not (attackType eq "melee" or attackType eq "ranged" or attackType eq "magic")
!mmm     do whisperback("m3mgdProcessAttackXP(): no or invalid attackType parameter: " & attackType & " -- no experience processed.")
!mmm     return false
!mmm   end if
!mmm   
!mmm   if isdefault(attackDamageRoll) or attackDamageRoll <= 0
!mmm     do whisperback("m3mgdProcessAttackXP(): no or invalid attackDamageRoll parameter: " & attackDamageRoll & " -- no experience processed.")
!mmm     return false
!mmm   end if
!mmm   
!mmm   if isdefault(attackerID)
!mmm     set attackerID = m3mgdExchange.(m3mgdAttrAttackerID)
!mmm   end if
!mmm   if not isChar(attackerID)
!mmm     do whisperback("m3mgdProcessAttackXP(): Unable to process experience for attack: attacker '" & attackerID.name & "' not linked to a character sheet.")
!mmm     return false
!mmm   else if attackerID.permission ne "control"
!mmm     do whisperback("m3mgdProcessAttackXP(): Unable to process experience for attack: no control over token '" & attackerID.name & "'")
!mmm     return false
!mmm   end if
!mmm
!mmm   if isdefault(targetID)
!mmm     set targetID = script.cOwnID
!mmm   end if
!mmm   if targetID.permission ne "view" and targetID.permission ne "control"
!mmm     do whisperback("m3mgdProcessAttackXP(): Unable to process experience for attack: invalid target token or no view access to token '" & targetID.name & "'")
!mmm     return false
!mmm   end if
!mmm   
!mmm   set xpGain = targetID.Grad + 3
!mmm   set xpTooltip = targetID.Grad & "[Grad]+3"
!mmm   if attackType eq "ranged" or attackType eq "magic"
!mmm     set xpGain = xpGain / 2
!mmm     set xpTooltip = "(" & xpTooltip & ") /2"
!mmm     if attackType eq "ranged" 
!mmm       set xpTooltip = xpTooltip & "[FK]"
!mmm     else if attackType eq "magic"
!mmm       set xpTooltip = xpTooltip & "[✨]"
!mmm     end if
!mmm   end if
!rem   // Devastating hits
!mmm   if attackDamageRoll >= 8 and cTargetID.(m3mgdGetEnduranceAttribute(cTargetID)) >= 8
!mmm     set xpGain = xpGain * 2
!mmm     set xpTooltip = "(" & xpTooltip & ") x2[verheerend]"
!mmm   end if
!mmm   
!mmm   set newXP = attackerID.(m3mgdAttrXP) + xpGain
!mmm   if newXP <= 0 or not newXP
!mmm     do whisperback("m3mgdProcessAttackXP(): Failure: new calculated XP likely undefined ('" & newXP & "') -- no experience processed.")
!mmm     return false
!mmm   end if
!mmm   if setattr(attackerID, m3mgdAttrXP, newXP) != newXP
!mmm     do whisperback("m3mgdProcessAttackXP(): Failure storing new experience total " & newXP & " in attribute '" & attackerID.name & "'." & m3mgdAttrXP)
!mmm     return false
!mmm   end if
!mmm
!mmm   set xpLog = attackerID.(m3mgdAttrXP) & "(+" & xpGain & ")=Angriff (" & attackType & ", Wurf: " & attackDamageRoll & ") auf " & targetID.name & " (Grad: " & targetID.Grad & ") = " & xpTooltip
!mmm   if isunknown(attackerID.(m3mgdAttrXPLog))
!mmm     do setattr(attackerID, m3mgdAttrXPLog, "")
!mmm   end if
!mmm   do setattr(attackerID, m3mgdAttrXPLog, attackerID.(m3mgdAttrXPLog) & " {\{" & xpLog & "}\} ")
!mmm
!mmm   return highlight(xpGain, "normal", xpTooltip)
!mmm
!mmm end function
!rem
!rem // m3mgdRerunButton(tokenID, weaponsGroup, weaponLabel, rollData)
!rem //
!mmm function m3mgdRerunButton(tokenID, weaponsGroup, weaponLabel, rollData)
!mmm   set payload = _m3mgdWeaponButtonPayload(tokenID, weaponsGroup, weaponLabel, rollData)
!mmm   return " [🗘](" & payload & cssTableHeaderButton & ") "
!mmm end function
!rem
!rem // m3mgdDefenseDataTable()
!rem //
!mmm function m3mgdDefenseDataTable()
!mmm
!rem   // Prepare output
!rem
!mmm   set prvEndurance = script.endurance
!mmm   set prvHealth = script.health
!mmm   set shapeMoji = m3mgdShapeMoji(script.cOwnID)
!mmm
!mmm   if script.criticalAttack
!mmm     set attackResult = highlight(script.attackResult, "good", "Kritisch erfolgreicher Angriff von " & m3mgdExchange.(m3mgdAttrAttackerID).name)
!mmm   else
!mmm     set attackResult = highlight(script.attackResult, "info", "Angriff von " & m3mgdExchange.(m3mgdAttrAttackerID).name)
!mmm   end if
!mmm   set attackDamage = highlight(m3mgdExchange.(m3mgdAttrAttackDamage), "info", m3mgdExchange.(m3mgdAttrAttackType))
!mmm   set effEnduranceLoss = highlight(script.effEnduranceLoss, "normal")
!mmm   set effHealthLoss = highlight(script.effHealthLoss, "normal", "RS: " & script.effArmorProtection)
!mmm
!mmm   set sender = script.cOwnID.token_name
!rem
!rem   // Build data table
!rem
!mmm   combine chat
!mmm
!mmm     if script.cGMSilentMode
!mmm       chat: /w GM 
!mmm     end if
!mmm
!mmm     chat: ${"&"}{template:default} 
!mmm
!mmm     if script.cNoDefense
!mmm       set heading = "Keine Abwehr (wehrlos)"
!mmm     else if m3mgdExchange.(m3mgdAttrAttackType) eq "magic"
!mmm       set heading = "Abwehr gegen " & m3mgdExchange.(m3mgdAttrAttackType).max
!mmm     else if script.cWeaponLabel eq "Abwehr ohne Schild"
!mmm       set heading = "Abwehr ohne Schild"
!mmm     else
!mmm       set heading = "Abwehr mit " & script.cWeaponLabel
!mmm     end if 
!mmm     chat: {\{name=${shapeMoji}${script.cOwnID.name}: ${heading}
!mmm     do chat(m3mgdRerunButton(script.cOwnID, "defense", script.cWeaponLabel, {"cDefenseRoll": cDefenseRoll}))
!mmm     chat: }\}
!mmm
!mmm     if attackDamage & "" eq "0"
!mmm       chat: {\{Angriff=**${attackResult}&nbsp;/&nbsp;Sonderschaden**}\}
!mmm     else if attackDamage > 0
!mmm       chat: {\{Angriff=**${attackResult}&nbsp;/&nbsp;${attackDamage}&nbsp;Schaden**}\}
!mmm     else
!mmm       chat: {\{Angriff=${attackResult} }\}
!mmm     end if
!mmm
!mmm     if script.defenseSuccess and iscritical(script.cDefenseRoll) and not script.criticalAttack
!mmm       chat: {\{Kritischer Abwehrerfolg=${script.defenseResult} **Leichter Treffer** [🎲](${m3mgdCriticalEffectRollPayload(script.cOwnID, "defenseSuccess", m3mgdExchange.(m3mgdAttrAttackerID))}${cssTableCellButton}) }\}
!mmm     else if script.defenseSuccess
!mmm       chat: {\{Abwehrerfolg=${script.defenseResult} **Leichter Treffer**}\}
!mmm     else if script.criticalAttack == true and isfumble(script.cDefenseRoll)
!mmm       chat: {\{Kritischer Fehlschlag bei Abwehr eines kritischen Treffers=${script.defenseResult} **Schwerer kritischer Treffer** 
!mmm       chat: [🎲](${m3mgdCriticalEffectRollPayload(m3mgdExchange.(m3mgdAttrAttackerID), "attackSuccess", script.cOwnID)}${cssTableCellButton})
!mmm       chat: [🎲](${m3mgdCriticalEffectRollPayload(script.cOwnID, "defenseFailure", m3mgdExchange.(m3mgdAttrAttackerID))}${cssTableCellButton}) }\}
!mmm     else if script.criticalAttack == true
!mmm       chat: {\{Fehlschlag=${script.defenseResult} **Schwerer kritischer Treffer** [🎲](${m3mgdCriticalEffectRollPayload(m3mgdExchange.(m3mgdAttrAttackerID), "attackSuccess", script.cOwnID)}${cssTableCellButton}) }\}
!mmm     else if isfumble(script.cDefenseRoll)
!mmm       chat: {\{Kritischer Fehlschlag=${script.defenseResult} **Schwerer kritischer Treffer** [🎲](${m3mgdCriticalEffectRollPayload(m3mgdExchange.(m3mgdAttrAttackerID), "defenseFailure", script.cOwnID)}${cssTableCellButton}) }\}
!mmm     else 
!mmm       chat: {\{Ergebnis=${script.defenseResult} **Schwerer Treffer**}\}
!mmm     end if
!mmm
!mmm     if script.defenseSuccess and effEnduranceLoss > 0
!mmm       chat: {\{Schaden=**${effEnduranceLoss}&nbsp;AP**}\}
!mmm     else if not script.defenseSuccess and attackDamage & "" eq "0"
!mmm       chat: {\{Schaden=**SPEZIAL**}\}
!mmm     else if not script.defenseSuccess
!mmm       chat: {\{Schaden=**${effHealthLoss}&nbsp;LP&nbsp;/&nbsp;${effEnduranceLoss}&nbsp;AP**}\}
!mmm     end if
!mmm
!mmm     if script.criticalAttack == true and m3mgdExchange.(m3mgdAttrAttackType) eq "magic"
!mmm       chat: {\{Kritischer Zaubererfolg=Zauber wirkt **doppelt so stark** oder ist **halb so teuer**: Nach Wahl des Zauberers umsetzen.}\}
!mmm     end if
!mmm
!mmm     if script.newHealth < 0 and script.timeToDie < 0
!mmm     
!mmm       chat: {\{&#10013;=${highlight("Sofortiger Tod", "bad", "Todeskampf: " & script.timeToDie-script.newHealth & "(🎲1d6)" & script.newHealth & "=" & script.timeToDie)} }\}
!mmm     
!mmm     else
!mmm     
!mmm       chat: {\{Zustand=${script.newHealth} **LP** / ${script.newEndurance} **AP**}\}
!mmm       chat: {\{${m3mgdHealthStatusLabel()}=${m3mgdHealthStatusEffectsDesc()} }\}
!mmm       chat: {\{${m3mgdEnduranceStatusLabel()}=${m3mgdEnduranceStatusEffectsDesc()} }\}
!mmm     
!mmm     end if
!mmm
!mmm   end combine
!mmm
!mmm   return true
!mmm   
!mmm end function
!rem
!rem // m3mgdChatDefensePrompt(targetID, [attackerID], weaponType)
!rem //
!mmm function m3mgdChatDefensePrompt(targetID, attackerID, weaponType, weaponsGroup)
!mmm   
!mmm   if isdefault(targetID) or not m3mgdValidateOwnTokenID(targetID)
!mmm     do whisperback("m3mgdChatDefensePrompt() called without a valid target ID.")
!mmm     return false
!mmm   end if
!mmm   if (isdefault(attackerID) or not m3mgdValidateOwnTokenID(attackerID)) and m3mgdValidateOwnTokenID(script.cOwnID)
!mmm     set attackerID = script.cOwnID
!mmm   else if isdefault(attackerID)
!mmm     do whisperback("m3mgdChatDefensePrompt() called without a valid attacker ID, defaulting to script.cOwnID failed.")
!mmm     return false
!mmm   end if
!mmm   
!mmm   if attackerID.PC 
!mmm     set sender = targetID.token_name
!mmm     chat: /w "${targetID.character_name}" ${m3mgdWeaponSelectorChatMenu(targetID, "defense", weaponType)}
!mmm   else
!mmm     set sender = attackerID.token_name
!mmm     set approvePayload = "!mmm script&#13;"
!mmm     set approvePayload = approvePayload & literal("!mmm do chat('" & attackerID.token_name & "', '/w \"" & targetID.character_name & "\" ' & m3mgdWeaponSelectorChatMenu(\"" & targetID & "\", \"defense\", \"" & weaponType & "\"))") & "&#13;"
!mmm     set approvePayload = approvePayload & "!mmm end script&#13;"
!mmm
!mmm     set rerollPayload = _m3mgdWeaponButtonPayload(attackerID, weaponsGroup, script.cWeaponLabel, default, { cTargetID: targetID, cSemiManualModifiers: script.cSemiManualModifiers, cManualModifiers: script.cManualModifiers })
!mmm
!mmm     chat: /w GM [🖅 **an ${targetID.character_name}**](${approvePayload}) &nbsp; *oder* &nbsp; [🎲 nochmal würfeln](${rerollPayload})
!mmm   end if
!mmm   return true
!mmm   
!mmm end function
!rem
!rem // m3mgdWeaponSpecialEffect(effect)
!rem //
!mmm function m3mgdWeaponSpecialEffect(effect, attackerID)
!mmm
!mmm   if isdefault(effect)
!mmm     return false
!mmm   end if
!mmm
!mmm   if effect eq "waterWalkerBlastEffect"
!mmm     
!mmm     do m3mgdRuneEffectWaterWalker(attackerID, default, "water-blast")
!mmm     
!mmm   end if
!mmm     
!mmm   return true
!mmm
!mmm end function
!rem
!rem // m3mgdInjuryFX(tokenID, relativeHealthLoss, relativeEnduranceLoss)
!rem //
!mmm function m3mgdInjuryFX(tokenID, relativeHealthLoss, relativeEnduranceLoss)
!mmm   
!mmm   set fx = ""
!mmm   if relativeHealthLoss >= .2
!mmm     set fx = "nova-blood"
!mmm   else if relativeHealthLoss > 0
!mmm     set fx = "bubbling-blood"
!mmm   else if relativeEnduranceLoss > .05
!mmm     set fx = "bubbling-water"
!mmm   end if
!mmm   if fx ne ""
!mmm     do delay(2)
!mmm     do spawnfx(fx, tokenID.left, tokenID.top)
!mmm     do delay(1)
!mmm     do spawnfx(fx, tokenID.left, tokenID.top)
!mmm   end if
!mmm   
!mmm   if relativeEnduranceLoss > 0 and tokenID.(m3mgdGetEnduranceAttribute(tokenID)) <= 0
!mmm     do m3mgdCancelRuneEffects(tokenID)
!mmm   end if
!mmm   
!mmm end function